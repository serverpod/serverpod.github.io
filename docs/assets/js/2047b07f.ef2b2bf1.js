"use strict";(self.webpackChunkserverpod_docs=self.webpackChunkserverpod_docs||[]).push([[31483],{75622:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"overview","title":"Overview","description":"Serverpod is an open-source backend framework for Flutter applications written in Dart\u200b. It aims to minimize boilerplate and integrate many common backend tasks out of the box\u200b. With Serverpod, Flutter developers can build secure, scalable server applications using the same language and tools as their client apps, benefiting from seamless code generation and a rich set of built-in capabilities.","source":"@site/docs/02-overview.md","sourceDirName":".","slug":"/overview","permalink":"/next/overview","draft":false,"unlisted":false,"editUrl":"https://github.com/serverpod/serverpod_docs/tree/main/docs/02-overview.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"4. Deploying Serverpod","permalink":"/next/get-started/deployment"},"next":{"title":"Support & community","permalink":"/next/support"}}');var s=t(74848),i=t(28453);const r={},o="Overview",d={},l=[{value:"Key capabilities",id:"key-capabilities",level:2},{value:"Defining Endpoints",id:"defining-endpoints",level:2},{value:"Data Models and Serialization",id:"data-models-and-serialization",level:2},{value:"Database Integration and ORM",id:"database-integration-and-orm",level:2},{value:"Conclusion",id:"conclusion",level:2}];function c(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"overview",children:"Overview"})}),"\n",(0,s.jsx)(n.p,{children:"Serverpod is an open-source backend framework for Flutter applications written in Dart\u200b. It aims to minimize boilerplate and integrate many common backend tasks out of the box\u200b. With Serverpod, Flutter developers can build secure, scalable server applications using the same language and tools as their client apps, benefiting from seamless code generation and a rich set of built-in capabilities."}),"\n",(0,s.jsx)(n.h2,{id:"key-capabilities",children:"Key capabilities"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Automatic code generation:"})," Serverpod analyzes your server code and automatically generates the client-side Dart API and data classes. Calling a remote endpoint becomes as simple as calling a local method."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"World-class logging:"})," Built-in logging and monitoring tools allow you to pinpoint exceptions and slow database queries through an easy-to-use interface\u200b."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Built-in caching:"})," High-performance, distributed caching is included. Any serializable model can be cached in memory on the server or distributed using Redis."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Easy-to-use ORM:"})," Serverpod provides an ORM that uses native Dart types and null-safety for database queries. You write Dart code instead of SQL, and Serverpod builds your Postgres queries under the hood. The ORM has an intuitive Dart-first API for relations and joins."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Database migrations:"})," A built-in migration system helps keep your database schema in sync as your project evolves. You can version schema changes and apply them easily during deployment\u200b."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"File uploads:"})," First-class support for file uploads to cloud storage or the database. Files can be stored in Amazon S3, Google Cloud Storage, or even in your PostgreSQL database\u200b."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Authentication:"})," User authentication comes ready out-of-the-box. Serverpod supports sign-in with Google, Apple, Firebase, email/password, or custom authentication mechanisms\u200b."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Real-time data streaming:"})," Support for real-time communications via Dart streams. You push serialized objects over secure WebSocket connections, enabling live updates (e.g., for chats and games)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Task scheduling:"})," Serverpod's future calls replace complicated cron jobs. Call a method anytime in the future or after a specified delay. The calls persist even if the server is restarted."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Deployment automation:"})," Serverpod Cloud (currently in private beta) allows you to deploy your server with zero configuration. There are also community-supported Terraform scripts for deployment on Google Cloud Platform and AWS, making it quick to provision infrastructure and deploy your server. Your Serverpod project comes with a Docker container for flexible deployment options."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Built-in web server:"})," Besides serving remote method calls, Serverpod comes with a traditional web server called Relic. It can serve web pages or act as a webhook/REST endpoint server. Relic is still experimental, but we're actively working on getting a stable release out in the next few months."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"defining-endpoints",children:"Defining Endpoints"}),"\n",(0,s.jsxs)(n.p,{children:["In Serverpod, endpoints are the entry points that clients call to execute server-side logic. An endpoint is defined by creating a class that extends the Endpoint class and adding asynchronous methods to it. Each endpoint method must return a ",(0,s.jsx)(n.code,{children:"Future<Type>"})," and take a ",(0,s.jsx)(n.code,{children:"Session"})," object as its first parameter\u200b. The ",(0,s.jsx)(n.code,{children:"Session"})," provides context about the call and gives access to server resources like the database or cache."]}),"\n",(0,s.jsx)(n.p,{children:"For example, here's a simple endpoint definition with a single method:\u200b"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"import 'package:serverpod/serverpod.dart';\n\nclass GreetingEndpoint extends Endpoint {\n  Future<String> hello(Session session, String name) async {\n    return 'Hello $name';\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["You can place your endpoints anywhere in your server package. After adding or modifying endpoints, you run the Serverpod code generator (",(0,s.jsx)(n.code,{children:"serverpod generate"}),") to update the client interface. The generator produces a Dart client library that mirrors your server API."]}),"\n",(0,s.jsx)(n.p,{children:"On the Flutter client side, calling the endpoint is as straightforward as calling a local function. For instance, using the generated client, you can invoke the above hello method like this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"final result = await client.greeting.hello('World');\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Serverpod handles the network communication and data serialization behind the scenes. Under the hood, it uses JSON serialization and HTTP or WebSocket calls, but as a developer, you only see calls using the typed Dart interface. For more details on defining and using endpoints, see the ",(0,s.jsx)(n.a,{href:"./concepts/working-with-endpoints",children:"Working with endpoints"})," guide in the documentation."]}),"\n",(0,s.jsx)(n.h2,{id:"data-models-and-serialization",children:"Data Models and Serialization"}),"\n",(0,s.jsxs)(n.p,{children:["Serverpod makes it easy to define the data models that your server will use in its API and when talking with the database. You define serializable data models in YAML files (with a ",(0,s.jsx)(n.code,{children:".spy.yaml"})," extension, short for ",(0,s.jsx)(n.em,{children:"Serverpod YAML"}),"). These model definitions are used to generate Dart classes that are shared by the server and the app, ensuring a consistent data schema on both sides\u200b. If a database table is associated with the model, the code generator will also produce the necessary database integration code."]}),"\n",(0,s.jsx)(n.p,{children:"A simple model definition might look like this\u200b:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"class: Company\nfields:\n  name: String\n  foundedDate: DateTime?\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This defines a ",(0,s.jsx)(n.code,{children:"Company"})," class with two fields. When you run ",(0,s.jsx)(n.code,{children:"serverpod generate"}),", Serverpod creates a Dart class named ",(0,s.jsx)(n.code,{children:"Company"})," (with a ",(0,s.jsx)(n.code,{children:"name"})," and ",(0,s.jsx)(n.code,{children:"foundedDate"})," property) that can be used in your endpoint methods and in the client code."]}),"\n",(0,s.jsxs)(n.p,{children:["By default, model classes are plain data holders that can be sent over the network. Serverpod supports most basic types, including ",(0,s.jsx)(n.code,{children:"bool"}),", ",(0,s.jsx)(n.code,{children:"int"}),", ",(0,s.jsx)(n.code,{children:"double"}),", ",(0,s.jsx)(n.code,{children:"String"}),", ",(0,s.jsx)(n.code,{children:"Duration"}),", ",(0,s.jsx)(n.code,{children:"DateTime"}),", ",(0,s.jsx)(n.code,{children:"ByteData"}),", ",(0,s.jsx)(n.code,{children:"UuidValue"}),", ",(0,s.jsx)(n.code,{children:"Uri"}),", and ",(0,s.jsx)(n.code,{children:"BigInt"}),". You can also use ",(0,s.jsx)(n.code,{children:"List"}),", ",(0,s.jsx)(n.code,{children:"Map"}),", ",(0,s.jsx)(n.code,{children:"Set"}),", and other custom serializable objects. Null safety is supported, and the models can be nested with each other as needed."]}),"\n",(0,s.jsx)(n.h2,{id:"database-integration-and-orm",children:"Database Integration and ORM"}),"\n",(0,s.jsxs)(n.p,{children:["If you want a model to also correspond to a database table, you simply add a table name to the YAML definition. For example, to back the ",(0,s.jsx)(n.code,{children:"Company"})," class with a database table, you could write:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"class: Company\ntable: company\nfields:\n  name: String\n  foundedDate: DateTime?\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Including the ",(0,s.jsx)(n.code,{children:"table"})," key tells Serverpod to set up a PostgreSQL table named ",(0,s.jsx)(n.code,{children:"company"})," for this model and generate an ORM interface for it. After running ",(0,s.jsx)(n.code,{children:"serverpod generate"}),", the ",(0,s.jsx)(n.code,{children:"Company"})," Dart class will include additional capabilities for database operations."]}),"\n",(0,s.jsxs)(n.p,{children:["Working with a database in Serverpod is straightforward and fully integrated. By default, Serverpod uses a PostgreSQL database to store persistent data. Connection settings (such as host, port, database name, user, and password) are configured in your project's YAML files under the ",(0,s.jsx)(n.code,{children:"config/"})," directory\u200b. New Serverpod projects come pre-configured for a local Postgres instance, so you can usually start a development server without additional setup."]}),"\n",(0,s.jsxs)(n.p,{children:["When a data model is bound to a database table (via the table field in the model definition), Serverpod's code generation provides an Object-Relational Mapping (ORM) for that model. Each generated model class gains a static ",(0,s.jsx)(n.code,{children:"db"})," field that offers convenient methods for common database operations (CRUD). For example, you can insert a new record and then query it as follows:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"// Insert a new Company row into the database\nvar company = Company(name: 'Serverpod Inc.', foundedDate: DateTime.now());\ncompany = await Company.db.insertRow(session, company);\n\n// Retrieve the company by its id\nvar storedCompany = await Company.db.findById(session, company.id);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In the above snippet, ",(0,s.jsx)(n.code,{children:"insertRow"})," will write a new row to the ",(0,s.jsx)(n.code,{children:"company"})," table and return the inserted object with its ",(0,s.jsx)(n.code,{children:"id"})," (primary key) populated\u200b. The ",(0,s.jsx)(n.code,{children:"findById"})," call then fetches that row by its ",(0,s.jsx)(n.code,{children:"id"}),". All database calls are asynchronous and use the same ",(0,s.jsx)(n.code,{children:"Session"})," that is provided to your endpoint methods, ensuring they are executed in a transaction/context that you control. You can also perform more complex queries using Serverpod's fluent query interface \u2013 for example, searching with filters, joining relations, sorting, or even writing raw SQL if needed\u200b."]}),"\n",(0,s.jsx)(n.p,{children:"The ORM layer is fully type-safe; query filters and results are expressed in terms of your Dart classes and fields, preventing mistakes like SQL syntax errors or mismatched column types at compile time."}),"\n",(0,s.jsxs)(n.p,{children:["Serverpod\u2019s migration system further simplifies database work by allowing you to apply schema changes. Whenever you alter your models, you can generate a new migration by running ",(0,s.jsx)(n.code,{children:"serverpod create-migration"}),". Have Serverpod apply it on the next server startup by passing the ",(0,s.jsx)(n.code,{children:"--apply-migrations"})," flag when starting the server\u200b. This helps keep the database schema versioned and in sync with your code. See the documentation\u2019s ",(0,s.jsx)(n.a,{href:"./concepts/database/connection",children:"Database section"})," for details on writing complex queries, transactions, and managing migrations."]}),"\n",(0,s.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsxs)(n.p,{children:["Serverpod provides a robust, full-stack solution for Flutter backend development. Its high-level architecture (endpoints for RPC, YAML-defined serializable models, and an integrated PostgreSQL-backed ORM) allows teams to move quickly and safely when building out server features. Many auxiliary concerns \u2013 from caching and authentication to logging and deployment \u2013 are handled by Serverpod\u2019s built-in modules, reducing the need for additional services and glue code. This concise overview covered the basics; as a next step, you can explore the in-depth documentation on specific topics such as endpoints, database usage, or advanced features like streams and authentication to evaluate how Serverpod fits your project\u2019s needs. A great way to learn Serverpod is also to go through our ",(0,s.jsx)(n.a,{href:"/next/get-started/creating-endpoints",children:"Get started guide"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var a=t(96540);const s={},i=a.createContext(s);function r(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);