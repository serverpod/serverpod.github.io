"use strict";(self.webpackChunkserverpod_docs=self.webpackChunkserverpod_docs||[]).push([[21796],{74139:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>r,contentTitle:()=>a,default:()=>h,frontMatter:()=>c,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"concepts/database/indexing","title":"Indexing","description":"For performance reasons, you may want to add indexes to your database tables. These are added in the YAML-files defining the serializable objects.","source":"@site/versioned_docs/version-2.9.0/06-concepts/06-database/04-indexing.md","sourceDirName":"06-concepts/06-database","slug":"/concepts/database/indexing","permalink":"/concepts/database/indexing","draft":false,"unlisted":false,"editUrl":"https://github.com/serverpod/serverpod_docs/tree/main/versioned_docs/version-2.9.0/06-concepts/06-database/04-indexing.md","tags":[],"version":"2.9.0","sidebarPosition":4,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Relations with modules","permalink":"/concepts/database/relations/modules"},"next":{"title":"CRUD","permalink":"/concepts/database/crud"}}');var d=i(74848),t=i(28453);const c={},a="Indexing",r={},o=[{value:"Add an index",id:"add-an-index",level:3},{value:"Making fields unique",id:"making-fields-unique",level:3},{value:"Specifying index type",id:"specifying-index-type",level:3},{value:"Vector indexes",id:"vector-indexes",level:3},{value:"HNSW indexes",id:"hnsw-indexes",level:4},{value:"IVFFLAT indexes",id:"ivfflat-indexes",level:4},{value:"Distance functions",id:"distance-functions",level:4}];function l(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)(n.header,{children:(0,d.jsx)(n.h1,{id:"indexing",children:"Indexing"})}),"\n",(0,d.jsx)(n.p,{children:"For performance reasons, you may want to add indexes to your database tables. These are added in the YAML-files defining the serializable objects."}),"\n",(0,d.jsx)(n.h3,{id:"add-an-index",children:"Add an index"}),"\n",(0,d.jsxs)(n.p,{children:["To add an index, add an ",(0,d.jsx)(n.code,{children:"indexes"})," section to the YAML-file. The ",(0,d.jsx)(n.code,{children:"indexes"})," section is a map where the key is the name of the index and the value is a map with the index details."]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-yaml",children:"class: Company\ntable: company\nfields:\n  name: String\nindexes:\n  company_name_idx:\n    fields: name\n"})}),"\n",(0,d.jsxs)(n.p,{children:["The ",(0,d.jsx)(n.code,{children:"fields"})," keyword holds a comma-separated list of column names. These are the fields upon which the index is created. Note that the index can contain several fields."]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-yaml",children:"class: Company\ntable: company\nfields:\n  name: String\n  foundedAt: DateTime\nindexes:\n  company_idx:\n    fields: name, foundedAt\n"})}),"\n",(0,d.jsx)(n.h3,{id:"making-fields-unique",children:"Making fields unique"}),"\n",(0,d.jsx)(n.p,{children:"Adding a unique index ensures that the value or combination of values stored in the fields are unique for the table. This can be useful for example if you want to make sure that no two companies have the same name."}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-yaml",children:"class: Company\ntable: company\nfields:\n  name: String\nindexes:\n  company_name_idx:\n    fields: name\n    unique: true\n"})}),"\n",(0,d.jsxs)(n.p,{children:["The ",(0,d.jsx)(n.code,{children:"unique"})," keyword is a bool that can toggle the index to be unique, the default is set to false. If the ",(0,d.jsx)(n.code,{children:"unique"})," keyword is applied to a multi-column index, the index will be unique for the combination of the fields."]}),"\n",(0,d.jsx)(n.h3,{id:"specifying-index-type",children:"Specifying index type"}),"\n",(0,d.jsx)(n.p,{children:"It is possible to add a type key to specify the index type."}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-yaml",children:"class: Company\ntable: company\nfields:\n  name: String\nindexes:\n  company_name_idx:\n    fields: name\n    type: brin\n"})}),"\n",(0,d.jsxs)(n.p,{children:["If no type is specified the default is ",(0,d.jsx)(n.code,{children:"btree"}),". All ",(0,d.jsx)(n.a,{href:"https://www.postgresql.org/docs/current/indexes-types.html",children:"PostgreSQL index types"})," are supported, ",(0,d.jsx)(n.code,{children:"btree"}),", ",(0,d.jsx)(n.code,{children:"hash"}),", ",(0,d.jsx)(n.code,{children:"gist"}),", ",(0,d.jsx)(n.code,{children:"spgist"}),", ",(0,d.jsx)(n.code,{children:"gin"}),", ",(0,d.jsx)(n.code,{children:"brin"}),"."]}),"\n",(0,d.jsx)(n.h3,{id:"vector-indexes",children:"Vector indexes"}),"\n",(0,d.jsxs)(n.p,{children:["To enhance the performance of vector similarity search, it is possible to create specialized vector indexes on vector fields (",(0,d.jsx)(n.code,{children:"Vector"}),", ",(0,d.jsx)(n.code,{children:"HalfVector"}),", ",(0,d.jsx)(n.code,{children:"SparseVector"}),", ",(0,d.jsx)(n.code,{children:"Bit"}),"). Serverpod supports both ",(0,d.jsx)(n.code,{children:"hnsw"})," and ",(0,d.jsx)(n.code,{children:"ivfflat"})," index types with full parameter specification."]}),"\n",(0,d.jsx)(n.admonition,{type:"info",children:(0,d.jsx)(n.p,{children:"Each vector index can only be created on a single vector field. It is not possible to create a vector index on multiple fields of any kind."})}),"\n",(0,d.jsx)(n.h4,{id:"hnsw-indexes",children:"HNSW indexes"}),"\n",(0,d.jsx)(n.p,{children:"Hierarchical Navigable Small World (HNSW) indexes provide fast approximate nearest neighbor search:"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-yaml",children:"class: Document\ntable: document\nfields:\n  content: String\n  embedding: Vector(1536)\n  keywords: SparseVector(10000)\n  hash: Bit(256)\nindexes:\n  document_embedding_hnsw_idx:\n    fields: embedding\n    type: hnsw\n    distanceFunction: cosine\n    parameters:\n      m: 16\n      ef_construction: 64\n  document_keywords_idx:\n    fields: keywords\n    type: hnsw\n    distanceFunction: innerProduct\n    parameters:\n      m: 16\n      ef_construction: 64\n  document_hash_idx:\n    fields: hash\n    type: hnsw\n    distanceFunction: hamming\n    parameters:\n      m: 16\n      ef_construction: 64\n"})}),"\n",(0,d.jsx)(n.p,{children:"Available HNSW parameters:"}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"m"}),": Maximum number of bidirectional links for each node (default: 16)"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"ef_construction"}),": Size of the dynamic candidate list (default: 64)"]}),"\n"]}),"\n",(0,d.jsx)(n.h4,{id:"ivfflat-indexes",children:"IVFFLAT indexes"}),"\n",(0,d.jsx)(n.p,{children:"Inverted File with Flat compression (IVFFLAT) indexes are suitable for large datasets:"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-yaml",children:"class: Document\ntable: document\nfields:\n  content: String\n  embedding: Vector(1536)\nindexes:\n  document_embedding_ivfflat_idx:\n    fields: embedding\n    type: ivfflat\n    distanceFunction: innerProduct\n    parameters:\n      lists: 100\n"})}),"\n",(0,d.jsx)(n.p,{children:"Available IVFFLAT parameters:"}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"lists"}),": Number of inverted lists (default: 100)"]}),"\n"]}),"\n",(0,d.jsx)(n.h4,{id:"distance-functions",children:"Distance functions"}),"\n",(0,d.jsxs)(n.p,{children:["Supported distance functions for vector indexes (",(0,d.jsx)(n.code,{children:"distanceFunction"})," parameter):"]}),"\n",(0,d.jsxs)(n.table,{children:[(0,d.jsx)(n.thead,{children:(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.th,{children:"Distance Function"}),(0,d.jsx)(n.th,{children:"Description"}),(0,d.jsx)(n.th,{children:"Use Case"})]})}),(0,d.jsxs)(n.tbody,{children:[(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"l2"})}),(0,d.jsx)(n.td,{children:"Euclidean distance"}),(0,d.jsx)(n.td,{children:"Default for most embeddings"})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"innerProduct"})}),(0,d.jsx)(n.td,{children:"Inner product"}),(0,d.jsx)(n.td,{children:"When vectors are normalized"})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"cosine"})}),(0,d.jsx)(n.td,{children:"Cosine distance"}),(0,d.jsx)(n.td,{children:"Text embeddings"})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"l1"})}),(0,d.jsx)(n.td,{children:"Manhattan or taxicab distance"}),(0,d.jsx)(n.td,{children:"Sparse/high-dimensional data"})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"hamming"})}),(0,d.jsx)(n.td,{children:"Hamming distance"}),(0,d.jsx)(n.td,{children:"Binary vectors (Bit type)"})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"jaccard"})}),(0,d.jsx)(n.td,{children:"Jaccard distance"}),(0,d.jsx)(n.td,{children:"Binary vectors (Bit type)"})]})]})]}),"\n",(0,d.jsx)(n.p,{children:"Different vector types have specific limitations when creating indexes:"}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.strong,{children:"SparseVector"}),": Can only use HNSW indexes (IVFFLAT is not supported)."]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.strong,{children:"HalfVector"}),": When using IVFFLAT indexes, the L1 distance function is not supported."]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.strong,{children:"Bit"}),": Only supports ",(0,d.jsx)(n.code,{children:"hamming"})," (default) and ",(0,d.jsx)(n.code,{children:"jaccard"})," distance functions."]}),"\n"]}),"\n",(0,d.jsx)(n.admonition,{type:"tip",children:(0,d.jsx)(n.p,{children:"If more than one distance function is going to be frequently used on the same vector field, consider creating one index for each distance function to ensure optimal performance."})}),"\n",(0,d.jsxs)(n.p,{children:["For more details on vector indexes and its configuration, refer to the ",(0,d.jsx)(n.a,{href:"https://github.com/pgvector/pgvector/tree/master?tab=readme-ov-file#indexing",children:"pgvector extension documentation"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,d.jsx)(n,{...e,children:(0,d.jsx)(l,{...e})}):l(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>c,x:()=>a});var s=i(96540);const d={},t=s.createContext(d);function c(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(d):e.components||d:c(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);