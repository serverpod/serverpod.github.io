"use strict";(self.webpackChunkserverpod_docs=self.webpackChunkserverpod_docs||[]).push([[79983],{85090:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"concepts/sessions","title":"Sessions","description":"A Session in Serverpod is a request-scoped context object that exists for the duration of a single client request or connection. It provides access to server resources and maintains state during request processing.","source":"@site/docs/06-concepts/05-sessions.md","sourceDirName":"06-concepts","slug":"/concepts/sessions","permalink":"/next/concepts/sessions","draft":false,"unlisted":false,"editUrl":"https://github.com/serverpod/serverpod_docs/tree/main/docs/06-concepts/05-sessions.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Error handling and exceptions","permalink":"/next/concepts/exceptions"},"next":{"title":"Connection","permalink":"/next/concepts/database/connection"}}');var t=n(74848),r=n(28453);const a={},o="Sessions",l={},c=[{value:"Quick reference",id:"quick-reference",level:2},{value:"Essential properties",id:"essential-properties",level:3},{value:"Key methods",id:"key-methods",level:3},{value:"Session types",id:"session-types",level:2},{value:"Example: Automatic session (MethodCallSession)",id:"example-automatic-session-methodcallsession",level:3},{value:"Example: Manual session (InternalSession)",id:"example-manual-session-internalsession",level:3},{value:"Session lifecycle",id:"session-lifecycle",level:2},{value:"Internal Sessions",id:"internal-sessions",level:3},{value:"Session cleanup callbacks",id:"session-cleanup-callbacks",level:3},{value:"Logging",id:"logging",level:2},{value:"Common pitfalls and solutions",id:"common-pitfalls-and-solutions",level:2},{value:"Pitfall 1: Using session after method returns",id:"pitfall-1-using-session-after-method-returns",level:3},{value:"Pitfall 2: Forgetting to close manual sessions",id:"pitfall-2-forgetting-to-close-manual-sessions",level:3},{value:"Best practices",id:"best-practices",level:2},{value:"1. Let Serverpod manage sessions when possible",id:"1-let-serverpod-manage-sessions-when-possible",level:3},{value:"2. Use FutureCalls for delayed operations",id:"2-use-futurecalls-for-delayed-operations",level:3},{value:"3. Handle errors properly",id:"3-handle-errors-properly",level:3},{value:"Testing",id:"testing",level:2}];function d(e){const s={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.header,{children:(0,t.jsx)(s.h1,{id:"sessions",children:"Sessions"})}),"\n",(0,t.jsx)(s.p,{children:"A Session in Serverpod is a request-scoped context object that exists for the duration of a single client request or connection. It provides access to server resources and maintains state during request processing."}),"\n",(0,t.jsx)(s.p,{children:"Sessions are the gateway to Serverpod's functionality - every interaction with the database, cache, file storage, or messaging system happens through a session. The framework automatically creates the appropriate session type when a client makes a request, manages its lifecycle, and ensures proper cleanup when the request completes. For special cases like background tasks or system operations, you can also create and manage sessions manually."}),"\n",(0,t.jsx)(s.admonition,{type:"note",children:(0,t.jsxs)(s.p,{children:['A Serverpod Session should not be confused with the concept of "web sessions" or "user sessions" which persist over multiple API calls. See the ',(0,t.jsx)(s.a,{href:"/next/concepts/authentication/setup",children:"Authentication documentation"})," for managing persistent authentication."]})}),"\n",(0,t.jsx)(s.h2,{id:"quick-reference",children:"Quick reference"}),"\n",(0,t.jsx)(s.h3,{id:"essential-properties",children:"Essential properties"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:(0,t.jsx)(s.code,{children:"db"})})," - Database access. ",(0,t.jsx)(s.a,{href:"/next/concepts/database/connection",children:"See database docs"})]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:(0,t.jsx)(s.code,{children:"caches"})})," - Local and distributed caching. ",(0,t.jsx)(s.a,{href:"/next/concepts/caching",children:"See caching docs"})]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:(0,t.jsx)(s.code,{children:"storage"})})," - File storage operations. ",(0,t.jsx)(s.a,{href:"/next/concepts/file-uploads",children:"See file uploads"})]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:(0,t.jsx)(s.code,{children:"messages"})})," - Server events for real-time communication within and across servers. ",(0,t.jsx)(s.a,{href:"/next/concepts/server-events",children:"See server events docs"})]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:(0,t.jsx)(s.code,{children:"passwords"})})," - Credentials from config and environment. ",(0,t.jsx)(s.a,{href:"/next/concepts/configuration",children:"See configuration"})]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:(0,t.jsx)(s.code,{children:"authenticated"})})," - Current user authentication info. ",(0,t.jsx)(s.a,{href:"/next/concepts/authentication/basics",children:"See authentication docs"})]}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"key-methods",children:"Key methods"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:(0,t.jsx)(s.code,{children:"log(message, level)"})})," - Add log entry"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:(0,t.jsx)(s.code,{children:"addWillCloseListener(callback)"})})," - Register cleanup callback"]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"session-types",children:"Session types"}),"\n",(0,t.jsx)(s.p,{children:"Serverpod creates different session types based on the context:"}),"\n",(0,t.jsxs)(s.table,{children:[(0,t.jsx)(s.thead,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.th,{children:"Type"}),(0,t.jsx)(s.th,{children:"Created For"}),(0,t.jsx)(s.th,{children:"Lifetime"}),(0,t.jsx)(s.th,{children:"Common Use Cases"})]})}),(0,t.jsxs)(s.tbody,{children:[(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.strong,{children:"MethodCallSession"})}),(0,t.jsxs)(s.td,{children:[(0,t.jsx)(s.code,{children:"Future<T>"})," endpoint methods"]}),(0,t.jsx)(s.td,{children:"Single request"}),(0,t.jsx)(s.td,{children:"API calls, CRUD operations"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.strong,{children:"WebCallSession"})}),(0,t.jsx)(s.td,{children:"Web server routes"}),(0,t.jsx)(s.td,{children:"Single request"}),(0,t.jsx)(s.td,{children:"Web pages, form submissions"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.strong,{children:"MethodStreamSession"})}),(0,t.jsxs)(s.td,{children:[(0,t.jsx)(s.code,{children:"Stream<T>"})," endpoint methods"]}),(0,t.jsx)(s.td,{children:"Stream duration"}),(0,t.jsx)(s.td,{children:"Real-time updates, chat"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.strong,{children:"StreamingSession"})}),(0,t.jsx)(s.td,{children:"WebSocket connections"}),(0,t.jsx)(s.td,{children:"Connection duration"}),(0,t.jsx)(s.td,{children:"Live dashboards, multiplayer"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.strong,{children:"FutureCallSession"})}),(0,t.jsx)(s.td,{children:"Scheduled tasks"}),(0,t.jsx)(s.td,{children:"Task execution"}),(0,t.jsx)(s.td,{children:"Email sending, batch jobs"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.strong,{children:"InternalSession"})}),(0,t.jsx)(s.td,{children:"Manual creation"}),(0,t.jsx)(s.td,{children:"Until closed"}),(0,t.jsx)(s.td,{children:"Background work, migrations"})]})]})]}),"\n",(0,t.jsx)(s.h3,{id:"example-automatic-session-methodcallsession",children:"Example: Automatic session (MethodCallSession)"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-dart",children:"// lib/src/endpoints/example_endpoint.dart\nclass ExampleEndpoint extends Endpoint {\n  Future<String> hello(Session session, String name) async {\n    // MethodCallSession is created automatically\n    return 'Hello $name';\n    // Session closes automatically when method returns\n  }\n}\n"})}),"\n",(0,t.jsx)(s.h3,{id:"example-manual-session-internalsession",children:"Example: Manual session (InternalSession)"}),"\n",(0,t.jsx)(s.p,{children:"InternalSession is the only session type that requires manual management:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-dart",children:"Future<void> performMaintenance() async {\n  var session = await Serverpod.instance.createSession();\n  try {\n    // Perform operations\n    await cleanupOldRecords(session);\n    await updateStatistics(session);\n  } finally {\n    await session.close(); // Must close manually!\n  }\n}\n"})}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Important"}),": Always use try-finally with InternalSession to prevent memory leaks."]}),"\n",(0,t.jsx)(s.h2,{id:"session-lifecycle",children:"Session lifecycle"}),"\n",(0,t.jsx)(s.mermaid,{value:"flowchart TB\n    Request([Request/Trigger]) --\x3e Create[Session Created]\n    Create --\x3e Init[Initialize]\n    Init --\x3e Active[Execute Method]\n    Active --\x3e Close[Close Session]\n    Close --\x3e End([Request Complete])"}),"\n",(0,t.jsx)(s.p,{children:"Sessions follow a predictable lifecycle from creation to cleanup. When a client makes a request, Serverpod automatically creates the appropriate session type (see table above), initializes it with a unique ID, and sets up access to resources like the database, cache, and file storage."}),"\n",(0,t.jsx)(s.p,{children:"During the active phase, your operation executes with full access to Serverpod resources through the session. You can query the database, write logs, send messages, and access storage - all operations are tracked and tied to this specific session. When the operation completes, most sessions close automatically, writing any accumulated logs to the database and releasing all resources."}),"\n",(0,t.jsx)(s.h3,{id:"internal-sessions",children:"Internal Sessions"}),"\n",(0,t.jsxs)(s.p,{children:["The only exception is ",(0,t.jsx)(s.code,{children:"InternalSession"}),", which you create manually for background tasks. Manual sessions require explicit closure with ",(0,t.jsx)(s.code,{children:"session.close()"}),". Forgetting to close these sessions causes memory leaks as logs accumulate indefinitely. Always use try-finally blocks to ensure proper cleanup. After any session closes, attempting to use it throws a ",(0,t.jsx)(s.code,{children:"StateError"}),"."]}),"\n",(0,t.jsx)(s.h3,{id:"session-cleanup-callbacks",children:"Session cleanup callbacks"}),"\n",(0,t.jsxs)(s.p,{children:["You can register callbacks that execute just before a session closes using ",(0,t.jsx)(s.code,{children:"addWillCloseListener"}),". This is useful for cleanup operations, releasing resources, or performing final operations:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-dart",children:"Future<void> processData(Session session) async {\n  var tempFile = File('/tmp/processing_data.tmp');\n\n  // Register cleanup callback\n  session.addWillCloseListener((session) async {\n    if (await tempFile.exists()) {\n      await tempFile.delete();\n      session.log('Cleaned up temporary file');\n    }\n  });\n\n  // Process data using temp file\n  await tempFile.writeAsString('processing...');\n  // Session closes automatically, cleanup callback runs\n}\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Cleanup callbacks run in the order they were registered and are called for all session types, including manual sessions when you call ",(0,t.jsx)(s.code,{children:"session.close()"}),"."]}),"\n",(0,t.jsx)(s.h2,{id:"logging",children:"Logging"}),"\n",(0,t.jsxs)(s.p,{children:["Serverpod batches log entries for performance. During normal operations, logs accumulate in memory and are written to the database in a single batch when the session closes. This includes all your ",(0,t.jsx)(s.code,{children:"session.log()"})," calls, database query timings, and session metadata. The exception is streaming sessions (",(0,t.jsx)(s.code,{children:"MethodStreamSession"})," and ",(0,t.jsx)(s.code,{children:"StreamingSession"}),"), which write logs continuously by default to avoid memory buildup during long connections."]}),"\n",(0,t.jsx)(s.admonition,{type:"warning",children:(0,t.jsxs)(s.p,{children:["If you forget to close a manual session (",(0,t.jsx)(s.code,{children:"InternalSession"}),"), logs remain in memory indefinitely and are never persisted - this is a common cause of both memory leaks and missing debug information."]})}),"\n",(0,t.jsx)(s.h2,{id:"common-pitfalls-and-solutions",children:"Common pitfalls and solutions"}),"\n",(0,t.jsx)(s.h3,{id:"pitfall-1-using-session-after-method-returns",children:"Pitfall 1: Using session after method returns"}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Problem:"})," Using a session after it's closed throws a ",(0,t.jsx)(s.code,{children:"StateError"})]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-dart",children:"Future<void> processUser(Session session, int userId) async {\n  var user = await User.db.findById(session, userId);\n\n  // Schedule async work\n  Timer(Duration(seconds: 5), () async {\n    // \u274c Session is already closed!\n    // This will throw: StateError: Session is closed\n    await user.updateLastSeen(session);\n  });\n\n  return; // Session closes here\n}\n"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.strong,{children:"Solution 1 - Use FutureCalls:"})}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-dart",children:"Future<void> processUser(Session session, int userId) async {\n  var user = await User.db.findById(session, userId);\n\n  // Schedule through Serverpod\n  await session.serverpod.futureCallWithDelay(\n    'updateLastSeen',\n    UserIdData(userId: userId),\n    Duration(seconds: 5),\n  );\n\n  return;\n}\n"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.strong,{children:"Solution 2 - Create manual session:"})}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-dart",children:"Future<void> processUser(Session session, int userId) async {\n  var user = await User.db.findById(session, userId);\n\n  Timer(Duration(seconds: 5), () async {\n    // Create new session for async work\n    var newSession = await Serverpod.instance.createSession();\n    try {\n      await user.updateLastSeen(newSession);\n    } finally {\n      await newSession.close();\n    }\n  });\n\n  return;\n}\n"})}),"\n",(0,t.jsx)(s.h3,{id:"pitfall-2-forgetting-to-close-manual-sessions",children:"Pitfall 2: Forgetting to close manual sessions"}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.strong,{children:"Problem:"})}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-dart",children:"// \u274c Memory leak!\nvar session = await Serverpod.instance.createSession();\nvar users = await User.db.find(session);\n// Forgot to close - session leaks memory\n"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.strong,{children:"Solution - Always use try-finally:"})}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-dart",children:"var session = await Serverpod.instance.createSession();\ntry {\n  var users = await User.db.find(session);\n  // Process users\n} finally {\n  await session.close(); // Always runs\n}\n"})}),"\n",(0,t.jsx)(s.h2,{id:"best-practices",children:"Best practices"}),"\n",(0,t.jsx)(s.h3,{id:"1-let-serverpod-manage-sessions-when-possible",children:"1. Let Serverpod manage sessions when possible"}),"\n",(0,t.jsx)(s.p,{children:"Prefer using the session provided to your endpoint rather than creating new ones:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-dart",children:"// \u2705 Good - Use provided session\nFuture<List<User>> getActiveUsers(Session session) async {\n  return await User.db.find(\n    session,\n    where: (t) => t.isActive.equals(true),\n  );\n}\n\n// \u274c Avoid - Creating unnecessary session\nFuture<List<User>> getActiveUsers(Session session) async {\n  var newSession = await Serverpod.instance.createSession();\n  try {\n    return await User.db.find(newSession, ...);\n  } finally {\n    await newSession.close();\n  }\n}\n"})}),"\n",(0,t.jsx)(s.h3,{id:"2-use-futurecalls-for-delayed-operations",children:"2. Use FutureCalls for delayed operations"}),"\n",(0,t.jsx)(s.p,{children:"Instead of managing sessions for async work, use Serverpod's future call system:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-dart",children:"// \u2705 Good - Let Serverpod manage the session\nawait serverpod.futureCallWithDelay(\n  'processPayment',\n  PaymentData(orderId: order.id),\n  Duration(hours: 1),\n);\n\n// \u274c Complex - Manual session management\nFuture.delayed(Duration(hours: 1), () async {\n  var session = await Serverpod.instance.createSession();\n  try {\n    await processPayment(session, order.id);\n  } finally {\n    await session.close();\n  }\n});\n"})}),"\n",(0,t.jsx)(s.h3,{id:"3-handle-errors-properly",children:"3. Handle errors properly"}),"\n",(0,t.jsx)(s.p,{children:"Always handle exceptions to prevent unclosed sessions:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-dart",children:"// \u2705 Good - Errors won't prevent session cleanup\nFuture<void> safeOperation() async {\n  var session = await Serverpod.instance.createSession();\n  try {\n    await riskyOperation(session);\n  } catch (e) {\n    session.log('Operation failed: $e', level: LogLevel.error);\n    // Handle error appropriately\n  } finally {\n    await session.close();\n  }\n}\n"})}),"\n",(0,t.jsx)(s.h2,{id:"testing",children:"Testing"}),"\n",(0,t.jsxs)(s.p,{children:["When testing endpoints, the ",(0,t.jsx)(s.code,{children:"TestSessionBuilder"})," can be used to simulate and configure session properties for controlled test scenarios:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-dart",children:"withServerpod('test group', (sessionBuilder, endpoints) {\n  test('endpoint test', () async {\n    var result = await endpoints.users.getUser(sessionBuilder, 123);\n    expect(result.name, 'John');\n  });\n\n  test('authenticated endpoint test', () async {\n    const int userId = 1234;\n\n    var authenticatedSessionBuilder = sessionBuilder.copyWith(\n      authentication: AuthenticationOverride.authenticationInfo(userId, {Scope('user')}),\n    );\n\n    var result = await endpoints.users.updateProfile(\n      authenticatedSessionBuilder,\n      ProfileData(name: 'Jane')\n    );\n    expect(result.success, isTrue);\n  });\n});\n"})}),"\n",(0,t.jsxs)(s.p,{children:["For detailed testing strategies, see the ",(0,t.jsx)(s.a,{href:"/next/concepts/testing/get-started",children:"testing documentation"}),"."]})]})}function h(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,s,n)=>{n.d(s,{R:()=>a,x:()=>o});var i=n(96540);const t={},r=i.createContext(t);function a(e){const s=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),i.createElement(r.Provider,{value:s},e.children)}}}]);