"use strict";(globalThis.webpackChunkserverpod_docs=globalThis.webpackChunkserverpod_docs||[]).push([[1653],{23609(e,n,t){t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"concepts/authentication/providers/custom-providers/oauth2-utility/setup","title":"Setup","description":"The Serverpod Auth module provides generic OAuth2 utilities that simplify implementing custom identity providers. These utilities handle the complex OAuth2 authorization code flow with PKCE (Proof Key for Code Exchange), allowing you to integrate any OAuth2-compliant provider without dealing with low-level protocol details.","source":"@site/docs/06-concepts/11-authentication/04-providers/10-custom-providers/02-oauth2-utility/01-setup.md","sourceDirName":"06-concepts/11-authentication/04-providers/10-custom-providers/02-oauth2-utility","slug":"/concepts/authentication/providers/custom-providers/oauth2-utility/setup","permalink":"/next/concepts/authentication/providers/custom-providers/oauth2-utility/setup","draft":false,"unlisted":false,"editUrl":"https://github.com/serverpod/serverpod_docs/tree/main/docs/06-concepts/11-authentication/04-providers/10-custom-providers/02-oauth2-utility/01-setup.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Custom providers","permalink":"/next/concepts/authentication/providers/custom-providers/overview"},"next":{"title":"Creating an OAuth2-based Identity Provider","permalink":"/next/concepts/authentication/providers/custom-providers/oauth2-utility/creating-an-oauth2-based-identity-provider"}}');var r=t(74848),o=t(28453);const s={},a="Setup",c={},d=[{value:"Understanding OAuth2 with PKCE",id:"understanding-oauth2-with-pkce",level:2},{value:"The OAuth2 Flow",id:"the-oauth2-flow",level:3},{value:"Server-Side Implementation",id:"server-side-implementation",level:2},{value:"Configuration",id:"configuration",level:3},{value:"Configuration",id:"configuration-1",level:3},{value:"Exchanging Tokens",id:"exchanging-tokens",level:3},{value:"Initiating Authorization",id:"initiating-authorization",level:3},{value:"Exception Handling",id:"exception-handling",level:3},{value:"Platform-Specific Configuration",id:"platform-specific-configuration",level:3},{value:"iOS and macOS",id:"ios-and-macos",level:4},{value:"Android",id:"android",level:4},{value:"Web",id:"web",level:4},{value:"Complete Example of a Custom Provider",id:"complete-example-of-a-custom-provider",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Security Considerations",id:"security-considerations",level:3},{value:"Error Handling",id:"error-handling",level:3}];function l(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"setup",children:"Setup"})}),"\n",(0,r.jsx)(n.p,{children:"The Serverpod Auth module provides generic OAuth2 utilities that simplify implementing custom identity providers. These utilities handle the complex OAuth2 authorization code flow with PKCE (Proof Key for Code Exchange), allowing you to integrate any OAuth2-compliant provider without dealing with low-level protocol details."}),"\n",(0,r.jsx)(n.p,{children:"The OAuth2 utility consists of client-side and server-side components that work together to securely authenticate users:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:["Client-side (",(0,r.jsx)(n.code,{children:"OAuth2PkceUtil"}),")"]}),": Manages the authorization flow in your Flutter app, handling browser redirects and PKCE challenge generation."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:["Server-side (",(0,r.jsx)(n.code,{children:"OAuth2PkceUtil"}),")"]}),": Exchanges authorization codes for access tokens on your backend."]}),"\n"]}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.a,{href:"../../github/setup",children:"GitHub IDP"})," is built using these utilities, serving as a reference implementation for developers creating custom providers."]})}),"\n",(0,r.jsx)(n.h2,{id:"understanding-oauth2-with-pkce",children:"Understanding OAuth2 with PKCE"}),"\n",(0,r.jsx)(n.p,{children:"OAuth2 with PKCE is an authorization protocol that allows users to grant your application access to their data without sharing passwords. The PKCE extension adds an additional security layer, particularly important for mobile and public clients."}),"\n",(0,r.jsx)(n.h3,{id:"the-oauth2-flow",children:"The OAuth2 Flow"}),"\n",(0,r.jsx)(n.p,{children:"Here's how the complete flow works:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Generate Code Verifier"}),": Client generates a random cryptographic string (code verifier)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Generate Code Challenge"}),": Client creates a SHA-256 hash of the verifier (code challenge)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Authorization Request"}),": Client redirects user to provider with the code challenge."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"User Authorizes"}),": User logs in and grants permissions."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Receive Code"}),": Provider redirects back with an authorization code."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Token Exchange"}),": Client sends code + verifier to your backend."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Backend Exchange"}),": Backend exchanges code + verifier for access token."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Access Protected Resources"}),": Use access token to fetch user information."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"PKCE ensures that even if an attacker intercepts the authorization code, they cannot exchange it for an access token without the original code verifier."}),"\n",(0,r.jsx)(n.h2,{id:"server-side-implementation",children:"Server-Side Implementation"}),"\n",(0,r.jsx)(n.h3,{id:"configuration",children:"Configuration"}),"\n",(0,r.jsx)(n.h3,{id:"configuration-1",children:"Configuration"}),"\n",(0,r.jsx)(n.p,{children:"The OAuth2 utility requires a configuration object that defines how your server communicates with the OAuth2 provider's token endpoint. Create a server-side configuration for token exchange:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"import 'package:serverpod_auth_idp_server/core.dart';\n\nfinal config = OAuth2PkceServerConfig(\n  // Token endpoint URL for exchanging authorization codes\n  tokenEndpointUrl: Uri.https('oauth.provider.com', '/oauth/token'),\n\n  // OAuth client ID (must match client-side)\n  clientId: pod.getPassword('myProviderClientId')!,\n\n  // OAuth client secret (keep secure!)\n  clientSecret: pod.getPassword('myProviderClientSecret')!,\n\n  // Function to parse token response from provider\n  parseTokenResponse: (data) {\n    // Your parse logic here\n  },\n\n  // Optional: Where to send credentials (default: header)\n  credentialsLocation: OAuth2CredentialsLocation.header,\n\n  // Optional: Custom parameter names for credentials\n  clientIdKey: 'client_id',\n  clientSecretKey: 'client_secret',\n\n  // Optional: Custom headers for token requests\n  tokenRequestHeaders: {\n    'Accept': 'application/json',\n    'Content-Type': 'application/x-www-form-urlencoded',\n  },\n\n  // Optional: Additional parameters for token exchange\n  tokenRequestParams: {\n    'grant_type': 'authorization_code',\n  },\n);\n"})}),"\n",(0,r.jsxs)(n.admonition,{type:"info",children:[(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"credentialsLocation"})," parameter controls how your client credentials are sent to the OAuth2 provider:"]}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Header mode (recommended):"})," Credentials are placed in the ",(0,r.jsx)(n.code,{children:"Authorization"})," header using HTTP Basic authentication. This follows RFC\u202f6749 and is generally more secure, since sensitive values don't appear in the request body or logs."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Body mode:"})," Credentials are sent as form parameters in the request body.Use this only if your provider doesn't support header-based authentication."]}),"\n"]})]}),"\n",(0,r.jsx)(n.h3,{id:"exchanging-tokens",children:"Exchanging Tokens"}),"\n",(0,r.jsxs)(n.p,{children:["Using the previously created ",(0,r.jsx)(n.code,{children:"config"})," object, create the ",(0,r.jsx)(n.code,{children:"OAuth2PkceUtil"})," on your endpoint to exchange the authorization code:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"import 'package:serverpod/serverpod.dart';\nimport 'package:serverpod_auth_idp_server/core.dart';\n\nclass MyProviderIdpEndpoint extends Endpoint {\n  final oauth2Util = OAuth2PkceUtil(config: config);\n\n  Future<AuthSuccess> authenticate(\n    Session session, {\n    required String code,\n    required String codeVerifier,\n    required String redirectUri,\n  }) async {\n    try {\n      // Exchange authorization code for token response\n      final tokenResponse = await oauth2Util.exchangeCodeForToken(\n        code: code,\n        codeVerifier: codeVerifier,\n        redirectUri: redirectUri,\n      );\n\n      // Fetch user information from provider using access token\n      final userInfo = await _fetchUserInfo(session, tokenResponse.accessToken);\n\n      // Authenticate (find existing account or create new user)\n      final account = await _authenticate(session, userInfo);\n\n      // Issue authentication token to client\n      return await _issueToken(\n        session,\n        authUserId: account.authUserId,\n        scopes: account.scopes,\n      );\n    } on OAuth2InvalidResponseException catch (e) {\n      session.log('Invalid token response: ${e.message}');\n      throw Exception('Authentication failed');\n    } on OAuth2MissingAccessTokenException catch (e) {\n      session.log('Missing access token: ${e.message}');\n      throw Exception('Authentication failed');\n    } on OAuth2NetworkErrorException catch (e) {\n      session.log('Network error: ${e.message}');\n      throw Exception('Network error during authentication');\n    }\n  }\n\n  Future<Map<String, dynamic>> _fetchUserInfo(\n    Session session,\n    String accessToken,\n  ) async {\n    // Fetch user data from provider's API using the access token\n  }\n\n  Future<AccountResult> _authenticate(\n    Session session,\n    Map<String, dynamic> userInfo,\n  ) async {\n    // Find existing provider account or create new user based on provider user info\n    // Returns provider account (e.g., GoogleAccount, GitHubAccount) with authUserId linked to AuthUser\n  }\n\n  Future<AuthSuccess> _issueToken(\n    Session session, {\n    required int authUserId,\n    required Set<Scope> scopes,\n  }) async {\n    // Issue Serverpod authentication token for the authenticated user\n  }\n}\n\n### Exception Handling\n\nThe server-side utility throws these exceptions:\n\n| Exception | Description | Typical Cause |\n| ----------- | ------------- | --------------- |\n| `OAuth2InvalidResponseException` | Invalid response from provider | HTTP errors, malformed JSON |\n| `OAuth2MissingAccessTokenException` | Access token not in response | Provider didn't return token |\n| `OAuth2NetworkErrorException` | Network failure | Timeout, connection issues |\n| `OAuth2UnknownException` | Unexpected error | Unknown problems |\n\n## Client-Side Implementation\n\n### Configuration\n\nThe client-side OAuth2 utility also requires a configuration object that defines your provider's OAuth2 endpoints and authorization parameters. Create a client-side configuration:\n\n```dart\nimport 'package:serverpod_auth_idp_flutter/serverpod_auth_idp_flutter.dart';\n\nfinal config = OAuth2PkceProviderClientConfig(\n  // Your provider's authorization endpoint\n  authorizationEndpoint: Uri.https('oauth.provider.com', '/oauth/authorize'),\n\n  // OAuth client ID from your provider\n  clientId: 'your-client-id',\n\n  // Callback URI registered with your provider\n  redirectUri: 'myapp://auth-callback',\n\n  // URL scheme for the callback\n  callbackUrlScheme: 'myapp',\n\n  // Default permission scopes to request\n  defaultScopes: ['profile', 'email'],\n\n  // Additional query parameters for authorization request\n  additionalAuthParams: {\n    'response_mode': 'query',\n  },\n\n  // Separator for joining scopes (default: ' ')\n  scopeSeparator: ' ',\n\n  // Enable state parameter for CSRF protection (default: true)\n  enableState: true,\n\n  // Enable PKCE for OAuth2 flow (default: true)\n  enablePKCE: true,\n);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"initiating-authorization",children:"Initiating Authorization"}),"\n",(0,r.jsxs)(n.p,{children:["Using the previously created ",(0,r.jsx)(n.code,{children:"config"})," object, create an ",(0,r.jsx)(n.code,{children:"OAuth2PkceUtil"})," instance to start the authorization flow:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"final oauth2Util = OAuth2PkceUtil(config: config);\n\ntry {\n  final result = await oauth2Util.authorize(\n    // Optional: override default scopes\n    scopes: ['profile', 'email'],\n  );\n\n  // The authorization code to exchange for an access token\n  final code = result.code;\n\n  // The PKCE code verifier (required for token exchange)\n  final codeVerifier = result.codeVerifier;\n\n  // Send both to your backend\n  await client.myProviderIdp.authenticate(\n    code: code,\n    codeVerifier: codeVerifier,\n    redirectUri: config.redirectUri,\n  );\n} on OAuth2PkceUserCancelledException catch (e) {\n  // User cancelled the authorization flow\n  print('User cancelled: ${e.message}');\n} on OAuth2PkceStateMismatchException catch (e) {\n  // Possible CSRF attack detected\n  print('Security error: ${e.message}');\n} on OAuth2PkceMissingAuthorizationCodeException catch (e) {\n  // No authorization code in callback\n  print('Authorization failed: ${e.message}');\n} on OAuth2PkceProviderErrorException catch (e) {\n  // Provider returned an error\n  print('Provider error: ${e.message}');\n} on OAuth2PkceUnknownException catch (e) {\n  // Unexpected error\n  print('Unknown error: ${e.message}');\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"exception-handling",children:"Exception Handling"}),"\n",(0,r.jsx)(n.p,{children:"The client-side utility throws specific exceptions to help you handle different error scenarios:"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Exception"}),(0,r.jsx)(n.th,{children:"Description"}),(0,r.jsx)(n.th,{children:"Typical Cause"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"OAuth2PkceUserCancelledException"})}),(0,r.jsx)(n.td,{children:"User cancelled authorization"}),(0,r.jsx)(n.td,{children:"User closed browser/denied access"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"OAuth2PkceStateMismatchException"})}),(0,r.jsx)(n.td,{children:"State validation failed"}),(0,r.jsx)(n.td,{children:"Possible CSRF attack or browser issue"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"OAuth2PkceMissingAuthorizationCodeException"})}),(0,r.jsx)(n.td,{children:"No authorization code received"}),(0,r.jsx)(n.td,{children:"Provider didn't return expected code"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"OAuth2PkceProviderErrorException"})}),(0,r.jsx)(n.td,{children:"Provider returned error response"}),(0,r.jsx)(n.td,{children:"Invalid credentials, rate limiting"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"OAuth2PkceUnknownException"})}),(0,r.jsx)(n.td,{children:"Unexpected error occurred"}),(0,r.jsx)(n.td,{children:"Network issues, unknown problems"})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"platform-specific-configuration",children:"Platform-Specific Configuration"}),"\n",(0,r.jsxs)(n.p,{children:["The OAuth2 utility uses the ",(0,r.jsx)(n.a,{href:"https://pub.dev/packages/flutter_web_auth_2",children:"flutter_web_auth_2"})," package under the hood, which requires platform-specific setup."]}),"\n",(0,r.jsx)(n.h4,{id:"ios-and-macos",children:"iOS and macOS"}),"\n",(0,r.jsxs)(n.p,{children:['There is no special configuration needed for iOS and MacOS for "normal" authentication flows.\nHowever, if you are using ',(0,r.jsx)(n.strong,{children:"Universal Links"})," on iOS, they require redirect URIs to use ",(0,r.jsx)(n.strong,{children:"https"}),".\nFollow the instructions in the ",(0,r.jsx)(n.a,{href:"https://pub.dev/packages/flutter_web_auth_2#ios",children:"flutter_web_auth_2"})," documentation."]}),"\n",(0,r.jsx)(n.h4,{id:"android",children:"Android"}),"\n",(0,r.jsxs)(n.p,{children:["Add the callback activity to your ",(0,r.jsx)(n.code,{children:"AndroidManifest.xml"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<manifest>\n  <application>\n\n    <activity\n      android:name="com.linusu.flutter_web_auth_2.CallbackActivity"\n      android:exported="true">\n      <intent-filter android:label="flutter_web_auth_2">\n        <action android:name="android.intent.action.VIEW" />\n        <category android:name="android.intent.category.DEFAULT" />\n        <category android:name="android.intent.category.BROWSABLE" />\n        \x3c!-- Replace with your actual callback URL scheme --\x3e\n        <data android:scheme="myapp" />\n      </intent-filter>\n    </activity>\n\n  </application>\n</manifest>\n'})}),"\n",(0,r.jsx)(n.h4,{id:"web",children:"Web"}),"\n",(0,r.jsxs)(n.p,{children:["Create an HTML callback page in your ",(0,r.jsx)(n.code,{children:"./web"})," folder (e.g., ",(0,r.jsx)(n.code,{children:"auth.html"}),"):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-html",children:"<!DOCTYPE html>\n<title>Authentication complete</title>\n<p>Authentication is complete. If this does not happen automatically, please close the window.</p>\n<script>\n  function postAuthenticationMessage() {\n    const message = {\n      'flutter-web-auth-2': window.location.href\n    };\n\n    if (window.opener) {\n      window.opener.postMessage(message, window.location.origin);\n      window.close();\n    } else if (window.parent && window.parent !== window) {\n      window.parent.postMessage(message, window.location.origin);\n    } else {\n      localStorage.setItem('flutter-web-auth-2', window.location.href);\n      window.close();\n    }\n  }\n\n  postAuthenticationMessage();\n<\/script>\n"})}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsxs)(n.p,{children:["You only need a single callback file (e.g. ",(0,r.jsx)(n.code,{children:"auth.html"}),") in your ",(0,r.jsx)(n.code,{children:"./web"})," folder.\nThis file is shared across all IDPs that use the OAuth2 utility, as long as your redirect URIs point to it."]})}),"\n",(0,r.jsxs)(n.p,{children:["Make sure your redirect URI points to the callback file, e.g. ",(0,r.jsx)(n.code,{children:"https://yourdomain.com/auth.html"})]}),"\n",(0,r.jsx)(n.h2,{id:"complete-example-of-a-custom-provider",children:"Complete Example of a Custom Provider"}),"\n",(0,r.jsxs)(n.p,{children:["For a full end\u2011to\u2011end implementation of a custom OAuth2 provider \u2014 including server configuration, client setup and integration of all components \u2014 see the ",(0,r.jsx)(n.a,{href:"./creating-an-oauth2-based-identity-provider",children:"Complete Example"})," page."]}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsx)(n.h3,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Always Use PKCE"}),": Keep ",(0,r.jsx)(n.code,{children:"enablePKCE: true"})," in your client configuration. PKCE protects against authorization code interception attacks."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Validate State Parameter"}),": Keep ",(0,r.jsx)(n.code,{children:"enableState: true"})," to prevent CSRF attacks. The state parameter ensures the authorization response matches your request."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Secure Client Secret"}),": Never expose your client secret in client-side code. Store it securely in ",(0,r.jsx)(n.code,{children:"passwords.yaml"})," or environment variables on the server."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use HTTPS"}),": Always use HTTPS URLs for production endpoints. Only use HTTP for local development."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Validate Redirect URIs"}),": Ensure redirect URIs in your code exactly match those registered with your OAuth provider."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"error-handling",children:"Error Handling"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Catch Specific Exceptions"}),": Handle each exception type appropriately rather than using generic catch-all handlers."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Log Securely"}),": Log errors for debugging but never log sensitive data like tokens or secrets."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"User-Friendly Messages"}),": Show clear, actionable error messages to users without exposing technical details."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},28453(e,n,t){t.d(n,{R:()=>s,x:()=>a});var i=t(96540);const r={},o=i.createContext(r);function s(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);