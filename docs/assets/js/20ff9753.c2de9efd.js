"use strict";(self.webpackChunkserverpod_docs=self.webpackChunkserverpod_docs||[]).push([[81805],{92755:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"concepts/streams","title":"Streams and messaging","description":"For some applications, it\'s not enough to be able to call server-side methods. You may also want to push data from the server to the client or send data two-way. Examples include real-time games or chat applications. Luckily, Serverpod supports a framework for streaming data. It\'s possible to stream any serialized objects to or from any endpoint.","source":"@site/versioned_docs/version-2.2.0/06-concepts/15-streams.md","sourceDirName":"06-concepts","slug":"/concepts/streams","permalink":"/concepts/streams","draft":false,"unlisted":false,"editUrl":"https://github.com/serverpod/serverpod_docs/tree/main/versioned_docs/version-2.2.0/06-concepts/15-streams.md","tags":[],"version":"2.2.0","sidebarPosition":15,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Scheduling","permalink":"/concepts/scheduling"},"next":{"title":"Backward compatibility","permalink":"/concepts/backward-compatibility"}}');var a=s(74848),r=s(28453);const i={},o="Streams and messaging",d={},c=[{value:"Streaming Methods",id:"streaming-methods",level:2},{value:"Defining a streaming method",id:"defining-a-streaming-method",level:3},{value:"Lifecycle of a streaming method",id:"lifecycle-of-a-streaming-method",level:3},{value:"Authentication",id:"authentication",level:3},{value:"Error handling",id:"error-handling",level:3},{value:"Streaming Endpoints",id:"streaming-endpoints",level:2},{value:"Handling streams server-side",id:"handling-streams-server-side",level:3},{value:"The user object",id:"the-user-object",level:4},{value:"Internal server messaging",id:"internal-server-messaging",level:4},{value:"Handling streams in your app",id:"handling-streams-in-your-app",level:3}];function l(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"streams-and-messaging",children:"Streams and messaging"})}),"\n",(0,a.jsx)(n.p,{children:"For some applications, it's not enough to be able to call server-side methods. You may also want to push data from the server to the client or send data two-way. Examples include real-time games or chat applications. Luckily, Serverpod supports a framework for streaming data. It's possible to stream any serialized objects to or from any endpoint."}),"\n",(0,a.jsxs)(n.p,{children:["Serverpod supports two ways to stream data. The first approach, ",(0,a.jsx)(n.a,{href:"#streaming-methods",children:"streaming methods"}),", imitates how ",(0,a.jsx)(n.code,{children:"Streams"})," work in Dart and offers a simple interface that automatically handles the connection with the server. In contrast, the second approach, ",(0,a.jsx)(n.a,{href:"#streaming-endpoints",children:"streaming endpoint"}),", requires developers to manage the web socket connection. The second approach was Serverpod's initial solution for streaming data but will be removed in future updates."]}),"\n",(0,a.jsx)(n.h2,{id:"streaming-methods",children:"Streaming Methods"}),"\n",(0,a.jsxs)(n.p,{children:["When an endpoint method is defined with ",(0,a.jsx)(n.code,{children:"Stream"})," instead of ",(0,a.jsx)(n.code,{children:"Future"})," as the return type or includes ",(0,a.jsx)(n.code,{children:"Stream"})," as a method parameter, it is recognized as a streaming method. Streaming methods transmit data over a shared, self-managed web socket connection that automatically connects and disconnects from the server."]}),"\n",(0,a.jsx)(n.h3,{id:"defining-a-streaming-method",children:"Defining a streaming method"}),"\n",(0,a.jsxs)(n.p,{children:["Streaming methods are defined by using the ",(0,a.jsx)(n.code,{children:"Stream"})," type as either the return value or a parameter."]}),"\n",(0,a.jsx)(n.p,{children:"Following is an example of a streaming method that echoes back any message:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"class ExampleEndpoint extends Endpoint {\n  Stream echoStream(Session session, Stream stream) async* {\n    await for (var message in stream) {\n      yield message;\n    }\n  }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The generic for the ",(0,a.jsx)(n.code,{children:"Stream"})," can also be defined, e.g., ",(0,a.jsx)(n.code,{children:"Stream<String>"}),". This definition is then included in the client, enabling static type validation."]}),"\n",(0,a.jsx)(n.p,{children:"The streaming method above can then be called from the client like this:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"var inStream = StreamController();\nvar outStream = client.example.echoStream(inStream.stream);\noutStream.listen((message) {\n  print('Received message: $message');\n});\n\ninStream.add('Hello');\ninStream.add(42);\n\n// This will print\n// Received message: Hello\n// Received message: 42\n"})}),"\n",(0,a.jsxs)(n.p,{children:["In the example above, the ",(0,a.jsx)(n.code,{children:"echoStream"})," method passes back any message sent through the ",(0,a.jsx)(n.code,{children:"outStream"}),"."]}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsx)(n.p,{children:"Note that we can mix different types in the stream. This stream is defined as dynamic and can contain any type that can be serialized by Serverpod."})}),"\n",(0,a.jsx)(n.h3,{id:"lifecycle-of-a-streaming-method",children:"Lifecycle of a streaming method"}),"\n",(0,a.jsxs)(n.p,{children:["Each time the client calls a streaming method, a new ",(0,a.jsx)(n.code,{children:"Session"})," is created, and a call with that ",(0,a.jsx)(n.code,{children:"Session"})," is made to the method endpoint on the server. The ",(0,a.jsx)(n.code,{children:"Session"})," is automatically closed when the streaming method call is over."]}),"\n",(0,a.jsx)(n.p,{children:"If the web socket connection is lost, all streaming methods are closed on the server and the client."}),"\n",(0,a.jsxs)(n.p,{children:["When the streaming method is defined with a returning ",(0,a.jsx)(n.code,{children:"Stream"}),", the method is kept alive until the stream subscription is canceled on the client or the method returns."]}),"\n",(0,a.jsxs)(n.p,{children:["When the streaming method returns a ",(0,a.jsx)(n.code,{children:"Future"}),", the method is kept alive until the method returns."]}),"\n",(0,a.jsx)(n.p,{children:"Streams in parameters are closed when the stream is closed. This can be done by either closing the stream on the client or canceling the subscription on the server."}),"\n",(0,a.jsx)(n.p,{children:"All streams in parameters are closed when the method call is over."}),"\n",(0,a.jsx)(n.h3,{id:"authentication",children:"Authentication"}),"\n",(0,a.jsx)(n.p,{children:"Authentication is seamlessly integrated into streaming method calls. When a client initiates a streaming method, the server automatically authenticates the session."}),"\n",(0,a.jsxs)(n.p,{children:["Authentication is validated when the stream is first established, utilizing the authentication data stored in the ",(0,a.jsx)(n.code,{children:"Session"})," object. If a user's authentication is subsequently revoked\u2014requiring denial of access to the stream\u2014the stream will be promptly closed, and an exception will be thrown."]}),"\n",(0,a.jsxs)(n.p,{children:["For more details on handling revoked authentication, refer to the section on ",(0,a.jsx)(n.a,{href:"authentication/custom-overrides#Handling-revoked-authentication",children:"handling revoked authentication"}),"."]}),"\n",(0,a.jsx)(n.h3,{id:"error-handling",children:"Error handling"}),"\n",(0,a.jsx)(n.p,{children:"Error handling works just like in regular endpoint methods in Serverpod. If an exception is thrown on a stream, the stream is closed with an exception. If the exception thrown is a serializable exception, the exception is first serialized and passed over the stream before it is closed."}),"\n",(0,a.jsx)(n.p,{children:"This is supported in both directions; stream parameters can pass exceptions to the server, and return streams can pass exceptions to the client."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"class ExampleEndpoint extends Endpoint {\n  Stream echoStream(Session session, Stream stream) async* {\n    stream.listen((message) {\n      // Do nothing\n    }, onError: (error) {\n      print('Server received error: $error');\n      throw SerializableException('Error from server');\n    });\n  }\n}\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"var inStream = StreamController();\nvar outStream = client.example.echoStream(inStream.stream);\noutStream.listen((message) {\n  // Do nothing\n}, onError: (error) {\n  print('Client received error: $error');\n});\n\ninStream.addError(SerializableException('Error from client'));\n\n// This will print\n// Server received error: Error from client \n// Client received error: Error from server \n"})}),"\n",(0,a.jsx)(n.p,{children:"In the example above, the client sends an error to the server, which then throws an exception back to the client. And since the exception is serializable, it is passed over the stream before the stream is closed."}),"\n",(0,a.jsxs)(n.p,{children:["Read more about serializable exceptions here: ",(0,a.jsx)(n.a,{href:"exceptions",children:"Serializable exceptions"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"streaming-endpoints",children:"Streaming Endpoints"}),"\n",(0,a.jsx)(n.p,{children:"Streaming endpoints were Serverpod's first attempt at streaming data. This approach is more manual, requiring developers to manage the WebSocket connection to the server."}),"\n",(0,a.jsx)(n.h3,{id:"handling-streams-server-side",children:"Handling streams server-side"}),"\n",(0,a.jsx)(n.p,{children:"The Endpoint class has three methods you override to work with streams."}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"streamOpened"})," is called when a user connects to a stream on the Endpoint."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"streamClosed"})," is called when a user disconnects from a stream on the Endpoint."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"handleStreamMessage"})," is called when a serialized message is received from a client."]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["To send a message to a client, call the ",(0,a.jsx)(n.code,{children:"sendStreamMessage"})," method. You will need to include the session associated with the user."]}),"\n",(0,a.jsx)(n.h4,{id:"the-user-object",children:"The user object"}),"\n",(0,a.jsx)(n.p,{children:"It's often handy to associate a state together with a streaming session. Typically, you do this when a stream is opened."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"Future<void> streamOpened(StreamingSession session) async {\n  setUserObject(session, MyUserObject());\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["You can access the user object at any time by calling the ",(0,a.jsx)(n.code,{children:"getUserObject"})," method. The user object is automatically discarded when a session ends."]}),"\n",(0,a.jsx)(n.h4,{id:"internal-server-messaging",children:"Internal server messaging"}),"\n",(0,a.jsx)(n.p,{children:"A typical scenario when working with streams is to pass on messages from one user to another. For instance, if one client sends a chat message to the server, the server should send it to the correct user. Serverpod comes with a built-in messaging system that makes this easy. You can pass messages locally on a single server, but messages are passed through Redis by default. Passing the messages through Redis makes it possible to send the messages between multiple servers in a cluster."}),"\n",(0,a.jsxs)(n.p,{children:["In most cases, it's easiest to subscribe to a message channel in the ",(0,a.jsx)(n.code,{children:"streamOpened"})," method. The subscription will automatically be disposed of when the stream is closed. The following example will forward any message sent to a user identified by its user id."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"@override\nFuture<void> streamOpened(StreamingSession session) async {\n  final authenticationInfo = await session.authenticated;\n  final userId = authenticationInfo?.userId;\n  session.messages.addListener(\n    'user_$userId',\n    (message) {\n      sendStreamMessage(session, message);\n    },\n  );\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["In your ",(0,a.jsx)(n.code,{children:"handleStreamMessage"})," method, you can pass on messages to the correct channel."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"@override\nFuture<void> handleStreamMessage(\n  StreamingSession session,\n  SerializableModel message,\n) async {\n  if (message is MyChatMessage) {\n    session.messages.postMessage(\n      'user_${message.recipientId}',\n      message,\n    );\n  }\n}\n"})}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsxs)(n.p,{children:["For a real-world example, check out ",(0,a.jsx)(n.a,{href:"https://pixorama.live",children:"Pixorama"}),". It's a multi-user drawing experience showcasing Serverpod's real-time capabilities and comes with complete source code."]})}),"\n",(0,a.jsx)(n.h3,{id:"handling-streams-in-your-app",children:"Handling streams in your app"}),"\n",(0,a.jsx)(n.p,{children:"Before you can access streams in your client, you need to connect to the server's web socket. You do this by calling connectWebSocket on your client."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"await client.openStreamingConnection();\n\n"})}),"\n",(0,a.jsx)(n.p,{children:"You can monitor the state of the connection by adding a listener to the client.\nOnce connected to your server's web socket, you can pass and receive serialized objects."}),"\n",(0,a.jsx)(n.p,{children:"Listen to its web socket stream to receive updates from an endpoint on the server."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"await for (var message in client.myEndpoint.stream) {\n  _handleMessage(message);\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["You send messages to the server's endpoint by calling ",(0,a.jsx)(n.code,{children:"sendStreamMessage"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"client.myEndpoint.sendStreamMessage(MyMessage(text: 'Hello'));\n"})}),"\n",(0,a.jsx)(n.admonition,{type:"info",children:(0,a.jsx)(n.p,{children:"Authentication is handled automatically. If you have signed in, your web socket connection will be authenticated."})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>o});var t=s(96540);const a={},r=t.createContext(a);function i(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);