"use strict";(self.webpackChunkserverpod_docs=self.webpackChunkserverpod_docs||[]).push([[90049],{6759:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>d,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"concepts/working-with-endpoints","title":"Working with endpoints","description":"Endpoints are the connection points to the server from the client. With Serverpod, you add methods to your endpoint, and your client code will be generated to make the method call. For the code to be generated, you need to place the endpoint file anywhere under the lib directory of your server. Your endpoint should extend the Endpoint class. For methods to be generated, they need to return a typed Future, and its first argument should be a Session object. The Session object holds information about the call being made and provides access to the database.","source":"@site/docs/06-concepts/01-working-with-endpoints.md","sourceDirName":"06-concepts","slug":"/concepts/working-with-endpoints","permalink":"/next/concepts/working-with-endpoints","draft":false,"unlisted":false,"editUrl":"https://github.com/serverpod/serverpod_docs/tree/main/docs/06-concepts/01-working-with-endpoints.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Authentication","permalink":"/next/tutorials/authentication"},"next":{"title":"Working with models","permalink":"/next/concepts/models"}}');var i=t(74848),r=t(28453);const s={},d="Working with endpoints",a={},c=[{value:"Passing parameters",id:"passing-parameters",level:2},{value:"Return types",id:"return-types",level:2},{value:"Ignore endpoint definition",id:"ignore-endpoint-definition",level:2}];function l(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"working-with-endpoints",children:"Working with endpoints"})}),"\n",(0,i.jsxs)(n.p,{children:["Endpoints are the connection points to the server from the client. With Serverpod, you add methods to your endpoint, and your client code will be generated to make the method call. For the code to be generated, you need to place the endpoint file anywhere under the ",(0,i.jsx)(n.strong,{children:"lib"})," directory of your server. Your endpoint should extend the ",(0,i.jsx)(n.code,{children:"Endpoint"})," class. For methods to be generated, they need to return a typed ",(0,i.jsx)(n.code,{children:"Future"}),", and its first argument should be a ",(0,i.jsx)(n.code,{children:"Session"})," object. The ",(0,i.jsx)(n.code,{children:"Session"})," object holds information about the call being made and provides access to the database."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"import 'package:serverpod/serverpod.dart';\n\nclass ExampleEndpoint extends Endpoint {\n  Future<String> hello(Session session, String name) async {\n    return 'Hello $name';\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The above code will create an endpoint called ",(0,i.jsx)(n.code,{children:"example"})," (the Endpoint suffix will be removed) with the single ",(0,i.jsx)(n.code,{children:"hello"})," method. To generate the client-side code run ",(0,i.jsx)(n.code,{children:"serverpod generate"})," in the home directory of the server."]}),"\n",(0,i.jsx)(n.p,{children:"On the client side, you can now call the method by calling:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"var result = await client.example.hello('World');\n"})}),"\n",(0,i.jsx)(n.p,{children:"The client is initialized like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"// Sets up a singleton client object that can be used to talk to the server from\n// anywhere in our app. The client is generated from your server code.\n// The client is set up to connect to a Serverpod running on a local server on\n// the default port. You will need to modify this to connect to staging or\n// production servers.\nvar client = Client('http://$localhost:8080/')\n  ..connectivityMonitor = FlutterConnectivityMonitor();\n"})}),"\n",(0,i.jsxs)(n.p,{children:["If you run the app in an Android emulator, the ",(0,i.jsx)(n.code,{children:"localhost"})," parameter points to ",(0,i.jsx)(n.code,{children:"10.0.2.2"}),", rather than ",(0,i.jsx)(n.code,{children:"127.0.0.1"})," as this is the IP address of the host machine. To access the server from a different device on the same network (such as a physical phone) replace ",(0,i.jsx)(n.code,{children:"localhost"})," with the local ip address. You can find the local ip by running ",(0,i.jsx)(n.code,{children:"ifconfig"})," (Linux/MacOS) or ",(0,i.jsx)(n.code,{children:"ipconfig"})," (Windows)."]}),"\n",(0,i.jsxs)(n.p,{children:["Make sure to also update the ",(0,i.jsx)(n.code,{children:"publicHost"})," in the development config to make sure the server always serves the client with the correct path to assets etc."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"# your_project_server/config/development.yaml\n\napiServer:\n  port: 8080\n  publicHost: localhost # Change this line\n  publicPort: 8080\n  publicScheme: http\n...\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["You can pass the ",(0,i.jsx)(n.code,{children:"--watch"})," flag to ",(0,i.jsx)(n.code,{children:"serverpod generate"})," to watch for changed files and generate code whenever your source files are updated. This is useful during the development of your server."]})}),"\n",(0,i.jsx)(n.h2,{id:"passing-parameters",children:"Passing parameters"}),"\n",(0,i.jsxs)(n.p,{children:["There are some limitations to how endpoint methods can be implemented. Parameters and return types can be of type ",(0,i.jsx)(n.code,{children:"bool"}),", ",(0,i.jsx)(n.code,{children:"int"}),", ",(0,i.jsx)(n.code,{children:"double"}),", ",(0,i.jsx)(n.code,{children:"String"}),", ",(0,i.jsx)(n.code,{children:"UuidValue"}),", ",(0,i.jsx)(n.code,{children:"Duration"}),", ",(0,i.jsx)(n.code,{children:"DateTime"}),", ",(0,i.jsx)(n.code,{children:"ByteData"}),", or generated serializable objects (see next section). A typed ",(0,i.jsx)(n.code,{children:"Future"})," should always be returned. Null safety is supported. When passing a ",(0,i.jsx)(n.code,{children:"DateTime"})," it is always converted to UTC."]}),"\n",(0,i.jsxs)(n.p,{children:["You can also pass ",(0,i.jsx)(n.code,{children:"List"})," and ",(0,i.jsx)(n.code,{children:"Map"})," as parameters, but they need to be strictly typed with one of the types mentioned above. For ",(0,i.jsx)(n.code,{children:"Map"}),", the keys must be non-nullable strings. E.g., ",(0,i.jsx)(n.code,{children:"Map<String, int?>"})," is valid, but ",(0,i.jsx)(n.code,{children:"Map<int, String>"})," is not."]}),"\n",(0,i.jsxs)(n.admonition,{type:"warning",children:[(0,i.jsxs)(n.p,{children:["While it's possible to pass binary data through a method call and ",(0,i.jsx)(n.code,{children:"ByteData"}),", it is not the most efficient way to transfer large files. See our ",(0,i.jsx)(n.a,{href:"file-uploads",children:"file upload"})," interface. The size of a call is by default limited to 512 kB. It's possible to change by adding the ",(0,i.jsx)(n.code,{children:"maxRequestSize"})," to your config files. E.g., this will double the request size to 1 MB:"]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"maxRequestSize: 1048576\n"})})]}),"\n",(0,i.jsx)(n.h2,{id:"return-types",children:"Return types"}),"\n",(0,i.jsx)(n.p,{children:"The return type must be a typed Future. Supported return types are the same as for parameters."}),"\n",(0,i.jsx)(n.h2,{id:"ignore-endpoint-definition",children:"Ignore endpoint definition"}),"\n",(0,i.jsxs)(n.p,{children:["If you want the code generator to ignore an endpoint definition, you can annotate the class with ",(0,i.jsx)(n.code,{children:"@ignoreEndpoint"}),", imported from ",(0,i.jsx)(n.code,{children:"serverpod_shared/annotations.dart"}),".  This can be useful if you want to keep the definition in your codebase without generating server or client bindings for it."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"import 'package:serverpod/serverpod.dart';\nimport 'package:serverpod_shared/annotations.dart';\n\n@ignoreEndpoint\nclass ExampleEndpoint extends Endpoint {\n  Future<String> hello(Session session, String name) async {\n    return 'Hello $name';\n  }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"The above code will not generate any server or client bindings for the example endpoint."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>d});var o=t(96540);const i={},r=o.createContext(i);function s(e){const n=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);