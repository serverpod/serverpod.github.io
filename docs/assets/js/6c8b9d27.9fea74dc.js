"use strict";(self.webpackChunkserverpod_docs=self.webpackChunkserverpod_docs||[]).push([[78218],{78413:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>l,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"concepts/authentication/custom-overrides","title":"Custom overrides","description":"It is recommended to use the serverpodauthidp package but if you have special requirements not fulfilled by it, you can implement your authentication module. Serverpod is designed to make it easy to add custom authentication overrides.","source":"@site/versioned_docs/version-3.2.0/06-concepts/11-authentication/10-custom-overrides.md","sourceDirName":"06-concepts/11-authentication","slug":"/concepts/authentication/custom-overrides","permalink":"/concepts/authentication/custom-overrides","draft":false,"unlisted":false,"editUrl":"https://github.com/serverpod/serverpod_docs/tree/main/versioned_docs/version-3.2.0/06-concepts/11-authentication/10-custom-overrides.md","tags":[],"version":"3.2.0","sidebarPosition":10,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"UI Components","permalink":"/concepts/authentication/ui-components"},"next":{"title":"Setup","permalink":"/concepts/authentication/legacy/setup"}}');var r=t(74848),o=t(28453);const s={},a="Custom overrides",d={},c=[{value:"Server setup",id:"server-setup",level:2},{value:"Token validation",id:"token-validation",level:3},{value:"Scopes",id:"scopes",level:4},{value:"Handling revoked authentication",id:"handling-revoked-authentication",level:3},{value:"Parameters",id:"parameters",level:5},{value:"Revoked authentication messages",id:"revoked-authentication-messages",level:4},{value:"Send token to client",id:"send-token-to-client",level:3},{value:"Client setup",id:"client-setup",level:2},{value:"Configure auth key provider",id:"configure-auth-key-provider",level:3},{value:"Authentication schemes",id:"authentication-schemes",level:2},{value:"Implementing your own authentication scheme",id:"implementing-your-own-authentication-scheme",level:3}];function h(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",header:"header",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"custom-overrides",children:"Custom overrides"})}),"\n",(0,r.jsxs)(n.p,{children:["It is recommended to use the ",(0,r.jsx)(n.code,{children:"serverpod_auth_idp"})," package but if you have special requirements not fulfilled by it, you can implement your authentication module. Serverpod is designed to make it easy to add custom authentication overrides."]}),"\n",(0,r.jsx)(n.h2,{id:"server-setup",children:"Server setup"}),"\n",(0,r.jsx)(n.p,{children:"When running a custom auth integration it is up to you to build the authentication model and issuing auth tokens."}),"\n",(0,r.jsx)(n.h3,{id:"token-validation",children:"Token validation"}),"\n",(0,r.jsxs)(n.p,{children:["The token validation is performed by providing a custom ",(0,r.jsx)(n.code,{children:"AuthenticationHandler"})," callback when initializing Serverpod. The callback should return an ",(0,r.jsx)(n.code,{children:"AuthenticationInfo"})," object if the token is valid, otherwise ",(0,r.jsx)(n.code,{children:"null"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"// Initialize Serverpod and connect it with your generated code.\nfinal pod = Serverpod(\n  args,\n  Protocol(),\n  Endpoints(),\n  authenticationHandler: (Session session, String token) async {\n    /// Custom validation handler\n    if (token != 'valid') return null;\n\n    return AuthenticationInfo(1, <Scope>{});\n  },\n);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["In the above example, the ",(0,r.jsx)(n.code,{children:"authenticationHandler"})," callback is overridden with a custom validation method. The method returns an ",(0,r.jsx)(n.code,{children:"AuthenticationInfo"})," object with ",(0,r.jsx)(n.code,{children:"userIdentifier"})," ",(0,r.jsx)(n.code,{children:'"1"'}),' and no scopes if the token is the literal "valid", otherwise ',(0,r.jsx)(n.code,{children:"null"}),"."]}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"userIdentifier"})," passed to the ",(0,r.jsx)(n.code,{children:"AuthenticationInfo"})," constructor, as the first parameter, will always be converted to a ",(0,r.jsx)(n.code,{children:"String"})," and thus stored internally. Since the default implementation uses ",(0,r.jsx)(n.code,{children:"UuidValue"})," for the users, there is a convenience getter ",(0,r.jsx)(n.code,{children:"userId"}),", which returns the ",(0,r.jsx)(n.code,{children:"UuidValue"})," value."]})}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsxs)(n.p,{children:["In the ",(0,r.jsx)(n.code,{children:"authenticationHandler"})," callback the ",(0,r.jsx)(n.code,{children:"authenticated"})," field on the session will always be ",(0,r.jsx)(n.code,{children:"null"})," as it is the ",(0,r.jsx)(n.code,{children:"authenticationHandler"})," that figures out who the user is."]})}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsxs)(n.p,{children:["By specifying the optional ",(0,r.jsx)(n.code,{children:"authId"})," field in the ",(0,r.jsx)(n.code,{children:"AuthenticationInfo"})," object you can link the user to a specific authentication id. This is useful when revoking authentication for a specific device."]})}),"\n",(0,r.jsx)(n.h4,{id:"scopes",children:"Scopes"}),"\n",(0,r.jsxs)(n.p,{children:["The scopes returned from the ",(0,r.jsx)(n.code,{children:"authenticationHandler"})," is used to grant access to scope restricted endpoints. The ",(0,r.jsx)(n.code,{children:"Scope"})," class is a simple wrapper around a nullable ",(0,r.jsx)(n.code,{children:"String"})," in dart. This means that you can format your scopes however you want as long as they are in a String format."]}),"\n",(0,r.jsx)(n.p,{children:"Normally if you implement a JWT you would store the scopes inside the token. When extracting them all you have to do is convert the String stored in the token into a Scope object by calling the constructor."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"List<String> scopes = extractScopes(token);\nSet<Scope> userScopes = scopes.map((scope) => Scope(scope)).toSet();\n"})}),"\n",(0,r.jsx)(n.h3,{id:"handling-revoked-authentication",children:"Handling revoked authentication"}),"\n",(0,r.jsxs)(n.p,{children:["When a user's authentication is revoked, the server must be notified to respect the changes (e.g. to close method streams). Invoke the ",(0,r.jsx)(n.code,{children:"session.messages.authenticationRevoked"})," method and raise the appropriate event to notify the server."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"var userId = 1;\nvar revokedScopes = ['write'];\nvar message = RevokedAuthenticationScope(\n  scopes: revokedScopes,\n);\n\nawait session.messages.authenticationRevoked(\n  userId,\n  message,\n);\n"})}),"\n",(0,r.jsx)(n.h5,{id:"parameters",children:"Parameters"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"userId"})," - The user id belonging to the ",(0,r.jsx)(n.code,{children:"AuthenticationInfo"})," object to be revoked."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"message"})," - The revoked authentication event message. See below for the different type of messages."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"revoked-authentication-messages",children:"Revoked authentication messages"}),"\n",(0,r.jsxs)(n.p,{children:["There are three types of ",(0,r.jsx)(n.code,{children:"RevokedAuthentication"})," messages that are used to specify the extent of the authentication revocation:"]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Message type"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"RevokedAuthenticationUser"})}),(0,r.jsx)(n.td,{children:"All authentication is revoked for a user."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"RevokedAuthenticationAuthId"})}),(0,r.jsxs)(n.td,{children:["A single authentication id is revoked for the user. This should match the ",(0,r.jsx)(n.code,{children:"authId"})," field in the ",(0,r.jsx)(n.code,{children:"AuthenticationInfo"})," object."]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"RevokedAuthenticationScope"})}),(0,r.jsx)(n.td,{children:"List of scopes that have been revoked for a user."})]})]})]}),"\n",(0,r.jsx)(n.p,{children:"Each message type provides a tailored approach to revoke authentication based on different needs."}),"\n",(0,r.jsx)(n.h3,{id:"send-token-to-client",children:"Send token to client"}),"\n",(0,r.jsx)(n.p,{children:"You are responsible for implementing the endpoints to authenticate/authorize the user. But as an example such an endpoint could look like the following."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"class UserEndpoint extends Endpoint {\n  Future<LoginResponse> login(\n    Session session,\n    String username,\n    String password,\n  ) async {\n    var identifier = authenticateUser(session, username, password);\n    if (identifier == null) return null;\n\n    return issueMyToken(identifier, scopes: {});\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["In the above example, the ",(0,r.jsx)(n.code,{children:"login"})," method authenticates the user and creates an auth token. The token is then returned to the client."]}),"\n",(0,r.jsx)(n.h2,{id:"client-setup",children:"Client setup"}),"\n",(0,r.jsx)(n.p,{children:"Enabling authentication in the client is as simple as configuring an auth key provider. If an auth key provider is configured, the client will automatically query the provider for an authentication header value and include it in communication with the server."}),"\n",(0,r.jsx)(n.h3,{id:"configure-auth-key-provider",children:"Configure auth key provider"}),"\n",(0,r.jsxs)(n.p,{children:["Auth key providers need to implement the ",(0,r.jsx)(n.code,{children:"ClientAuthKeyProvider"})," interface. The provider is configured when creating the client by passing it as the named parameter ",(0,r.jsx)(n.code,{children:"authKeyProvider"}),". If no provider is configured, the client will not include authentication headers in requests to the server."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"import 'package:serverpod_client/serverpod_client.dart';\n\nclass SimpleAuthKeyProvider implements ClientAuthKeyProvider {\n  String? _key;\n\n  @override\n  Future<String?> get authHeaderValue async {\n    if (_key == null) return null;\n    return wrapAsBasicAuthHeaderValue(_key!);\n  }\n\n  Future<void> put(String key) async {\n    _key = key;\n  }\n\n  Future<void> remove() async {\n    _key = null;\n  }\n}\n\nvar client = Client('http://$localhost:8080/')\n  ..authKeyProvider = SimpleAuthKeyProvider()\n  ..connectivityMonitor = FlutterConnectivityMonitor();\n"})}),"\n",(0,r.jsxs)(n.p,{children:["In the above example, the ",(0,r.jsx)(n.code,{children:"SimpleAuthKeyProvider"})," is configured as the client's authentication key provider. The ",(0,r.jsx)(n.code,{children:"SimpleAuthKeyProvider"})," stores the token in memory and wraps it as a Basic auth header value using the ",(0,r.jsx)(n.code,{children:"wrapAsBasicAuthHeaderValue"})," utility function."]}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"SimpleAuthKeyProvider"})," is not practical and should only be used for testing. A secure implementation of the auth key provider is available in the ",(0,r.jsx)(n.code,{children:"serverpod_auth_core_flutter"})," package. It provides safe, persistent storage for the auth token."]})}),"\n",(0,r.jsxs)(n.p,{children:["The auth key provider is then available through the client's ",(0,r.jsx)(n.code,{children:"authKeyProvider"})," field. It is useful to create a getter for it to avoid unnecessary casting."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"var authProvider = client.authKeyProvider as SimpleAuthKeyProvider;\n"})}),"\n",(0,r.jsx)(n.p,{children:"It is the responsibility of the client to store the token in the auth key provider."}),"\n",(0,r.jsx)(n.h2,{id:"authentication-schemes",children:"Authentication schemes"}),"\n",(0,r.jsxs)(n.p,{children:["By default Serverpod will pass the authentication token from client to server in accordance with the HTTP ",(0,r.jsx)(n.code,{children:"authorization"})," header standard with the ",(0,r.jsx)(n.code,{children:"basic"})," scheme name and encoding. This is securely transferred as the connection is TLS encrypted."]}),"\n",(0,r.jsxs)(n.p,{children:["The default implementation encodes and wraps the user-provided token in a ",(0,r.jsx)(n.code,{children:"basic"})," scheme which is automatically unwrapped on the server side before being handed to the user-provided authentication handler described above."]}),"\n",(0,r.jsx)(n.p,{children:'In other words the default transport implementation is "invisible" to user code.'}),"\n",(0,r.jsx)(n.h3,{id:"implementing-your-own-authentication-scheme",children:"Implementing your own authentication scheme"}),"\n",(0,r.jsxs)(n.p,{children:["If you are implementing your own authentication and are using the ",(0,r.jsx)(n.code,{children:"basic"})," scheme, note that this is supported but will be automatically unwrapped i.e. decoded on the server side before being handed to your ",(0,r.jsx)(n.code,{children:"AuthenticationHandler"})," implementation. It will in this case receive the decoded auth key value after the ",(0,r.jsx)(n.code,{children:"basic"})," scheme name."]}),"\n",(0,r.jsxs)(n.p,{children:["If you are implementing a different authentication scheme, for example OAuth2 using bearer tokens, you should return the appropriate header value from the ",(0,r.jsx)(n.code,{children:"authHeaderValue"})," getter of your ",(0,r.jsx)(n.code,{children:"ClientAuthKeyProvider"})," implementation. You can use the utility functions ",(0,r.jsx)(n.code,{children:"wrapAsBasicAuthHeaderValue"})," or ",(0,r.jsx)(n.code,{children:"wrapAsBearerAuthHeaderValue"})," to format the token correctly."]}),"\n",(0,r.jsxs)(n.p,{children:["You will also need to implement the ",(0,r.jsx)(n.code,{children:"AuthenticationHandler"})," accordingly, in order to process that header value server-side."]}),"\n",(0,r.jsx)(n.p,{children:"The header value must be compliant with the HTTP header format defined in RFC 9110 HTTP Semantics, 11.6.2. Authorization.\nSee:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization",children:"HTTP Authorization header"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://httpwg.org/specs/rfc9110.html#field.authorization",children:"RFC 9110, 11.6.2. Authorization"})}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"An approach to adding OAuth handling might make changes to the above code akin to the following."}),"\n",(0,r.jsx)(n.p,{children:"Client side:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"import 'package:serverpod_client/serverpod_client.dart';\n\nclass MyOAuthKeyProvider implements ClientAuthKeyProvider {\n  String? _key;\n\n  @override\n  Future<String?> get authHeaderValue async {\n    if (_key == null) return null;\n    return wrapAsBearerAuthHeaderValue(myBearerTokenObtainer(_key!));\n  }\n\n  Future<void> put(String key) async {\n    _key = key;\n  }\n\n  Future<void> remove() async {\n    _key = null;\n  }\n}\n\nvar client = Client('http://$localhost:8080/')\n  ..authKeyProvider = MyOAuthKeyProvider()\n  ..connectivityMonitor = FlutterConnectivityMonitor();\n"})}),"\n",(0,r.jsx)(n.p,{children:"Server side:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"// Initialize Serverpod and connect it with your generated code.\nfinal pod = Serverpod(\n  args,\n  Protocol(),\n  Endpoints(),\n  authenticationHandler: (Session session, String token) async {\n    /// Bearer token validation handler\n    var (uid, scopes) = myBearerTokenValidator(token)\n    if (uid == null) return null;\n\n    return AuthenticationInfo(uid, scopes);\n  },\n);\n"})})]})}function l(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>a});var i=t(96540);const r={},o=i.createContext(r);function s(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);