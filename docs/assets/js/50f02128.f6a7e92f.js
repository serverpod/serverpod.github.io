"use strict";(self.webpackChunkserverpod_docs=self.webpackChunkserverpod_docs||[]).push([[4531],{83758:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>s,default:()=>l,frontMatter:()=>a,metadata:()=>r,toc:()=>h});var i=t(85893),o=t(11151);const a={},s="Custom overrides",r={id:"concepts/authentication/custom-overrides",title:"Custom overrides",description:"Serverpod is designed to make it as simple as possible to implement custom authentication overrides. The framework comes with an integrated auth token creation, validation, and communication system. With a simple setup, it is easy to generate custom tokens and include them in authenticated communication with the server.",source:"@site/docs/05-concepts/10-authentication/05-custom-overrides.md",sourceDirName:"05-concepts/10-authentication",slug:"/concepts/authentication/custom-overrides",permalink:"/next/concepts/authentication/custom-overrides",draft:!1,unlisted:!1,editUrl:"https://github.com/serverpod/serverpod_docs/tree/main/docs/05-concepts/10-authentication/05-custom-overrides.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Custom providers",permalink:"/next/concepts/authentication/providers/custom-providers"},next:{title:"Uploading files",permalink:"/next/concepts/file-uploads"}},d={},h=[{value:"Server setup",id:"server-setup",level:2},{value:"Create auth token",id:"create-auth-token",level:3},{value:"Custom auth tokens",id:"custom-auth-tokens",level:4},{value:"Token validation format",id:"token-validation-format",level:3},{value:"Override token validation",id:"override-token-validation",level:4},{value:"Send token to client",id:"send-token-to-client",level:3},{value:"Remove auth token",id:"remove-auth-token",level:3},{value:"Remove specific tokens",id:"remove-specific-tokens",level:4},{value:"Custom token solution",id:"custom-token-solution",level:4},{value:"Client setup",id:"client-setup",level:2},{value:"Configure key manager",id:"configure-key-manager",level:3},{value:"Store token",id:"store-token",level:3},{value:"Remove token",id:"remove-token",level:3},{value:"Retrieve token",id:"retrieve-token",level:3}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",p:"p",pre:"pre",...(0,o.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"custom-overrides",children:"Custom overrides"}),"\n",(0,i.jsx)(n.p,{children:"Serverpod is designed to make it as simple as possible to implement custom authentication overrides. The framework comes with an integrated auth token creation, validation, and communication system. With a simple setup, it is easy to generate custom tokens and include them in authenticated communication with the server."}),"\n",(0,i.jsx)(n.h2,{id:"server-setup",children:"Server setup"}),"\n",(0,i.jsx)(n.p,{children:"After successfully authenticating a user, for example, through a username and password, an auth token can be created to preserve the authenticated user's permissions. This token is used to identify the user and facilitate endpoint authorization validation. When the user signs out, the token can be removed to prevent further access."}),"\n",(0,i.jsx)(n.h3,{id:"create-auth-token",children:"Create auth token"}),"\n",(0,i.jsxs)(n.p,{children:["To create an auth token, call the ",(0,i.jsx)(n.code,{children:"signInUser"})," method in the ",(0,i.jsx)(n.code,{children:"UserAuthentication"})," class, accessible through the ",(0,i.jsx)(n.code,{children:"session.auth"})," field on the ",(0,i.jsx)(n.code,{children:"session"})," object."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"signInUser"})," method takes three arguments: the first is a unique ",(0,i.jsx)(n.code,{children:"integer"})," identifier for the user, the second is information about the method used to authenticate the user, and the third is a set of scopes granted to the auth token."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"var authToken = await session.auth.signInUser(myUserObject.id, 'myAuthMethod', scopes: {\n    Scope('delete'),\n    Scope('create'),\n});\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The example above creates an auth token for a user with the unique identifier taken from ",(0,i.jsx)(n.code,{children:"myUserObject"}),". The auth token preserves that it was created using the method ",(0,i.jsx)(n.code,{children:"myAuthMethod"})," and has the scopes ",(0,i.jsx)(n.code,{children:"delete"})," and ",(0,i.jsx)(n.code,{children:"create"}),"."]}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsx)(n.p,{children:"The unique identifier for the user should uniquely identify the user regardless of authentication method. The information allows authentication tokens associated with the same user to be grouped."})}),"\n",(0,i.jsx)(n.h4,{id:"custom-auth-tokens",children:"Custom auth tokens"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"UserAuthentication"})," class simplifies the token management but makes assumptions about what information should be stored in the auth token. If your project has different requirements, managing auth tokens manually with your defined model is possible. Custom auth tokens require that the token validation is overridden and adjusted to the new auth token format, explained in ",(0,i.jsx)(n.a,{href:"#override-token-validation",children:"override token validation"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"token-validation-format",children:"Token validation format"}),"\n",(0,i.jsxs)(n.p,{children:["The framework requires tokens to be of ",(0,i.jsx)(n.code,{children:"String"})," type, and the default token validation expects the token to be in the format ",(0,i.jsx)(n.code,{children:"userId:key"}),". The ",(0,i.jsx)(n.code,{children:"userId"})," is the unique identifier for the user, and the ",(0,i.jsx)(n.code,{children:"key"})," is a generated auth token key. The ",(0,i.jsx)(n.code,{children:"userId"})," and ",(0,i.jsx)(n.code,{children:"key"})," are then retrieved from the token and validated towards the auth token stored as a result of the call to ",(0,i.jsx)(n.code,{children:"session.auth.signInUser(...)"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"var authToken = await session.auth.signInUser(....);\nvar verifiableToken = '${authToken.userId}:${authToken.key}';\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In the above example, the ",(0,i.jsx)(n.code,{children:"verifiableToken"})," is created by concatenating the ",(0,i.jsx)(n.code,{children:"userId"})," and ",(0,i.jsx)(n.code,{children:"key"})," from the ",(0,i.jsx)(n.code,{children:"authToken"}),". This token is then verifiable by the default token validation."]}),"\n",(0,i.jsx)(n.h4,{id:"override-token-validation",children:"Override token validation"}),"\n",(0,i.jsxs)(n.p,{children:["The token validation method can be overridden by providing a custom ",(0,i.jsx)(n.code,{children:"authenticationHandler"})," callback when initializing Serverpod. The callback should return an ",(0,i.jsx)(n.code,{children:"AuthenticationInfo"})," object if the token is valid, otherwise ",(0,i.jsx)(n.code,{children:"null"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"// Initialize Serverpod and connect it with your generated code.\nfinal pod = Serverpod(\n  args,\n  Protocol(),\n  Endpoints(),\n  authenticationHandler: (Session session, String token) async {\n    /// Custom validation handler\n    if (token != 'valid') return null;\n\n    return AuthenticationInfo(1, <Scope>{});\n  },\n);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In the above example, the ",(0,i.jsx)(n.code,{children:"authenticationHandler"})," callback is overridden with a custom validation method. The method returns an ",(0,i.jsx)(n.code,{children:"AuthenticationInfo"})," object with user id ",(0,i.jsx)(n.code,{children:"1"})," and no scopes if the token is valid, otherwise ",(0,i.jsx)(n.code,{children:"null"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"send-token-to-client",children:"Send token to client"}),"\n",(0,i.jsx)(n.p,{children:"After creating the token, it should be sent to the client. The client is then responsible for storing the token and including it in communication with the server. The token is usually sent in response to a successful sign-in request."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"class UserEndpoint extends Endpoint {\n  Future<String?> login(\n    Session session,\n    String username,\n    String password,\n  ) async {\n    var identifier = authenticateUser(session, username, password);\n    if (identifier == null) return null;\n\n    var authToken = await session.auth.signInUser(\n      identifier,\n      'username',\n      scopes: {},\n    );\n\n    return '${authToken.id}:${authToken.key}';\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In the above example, the ",(0,i.jsx)(n.code,{children:"login"})," method authenticates the user and creates an auth token. The token is then returned to the client in the format expected by the default token validation."]}),"\n",(0,i.jsx)(n.h3,{id:"remove-auth-token",children:"Remove auth token"}),"\n",(0,i.jsxs)(n.p,{children:["When the default token validation is used, signing out a user on all devices is made simple with the ",(0,i.jsx)(n.code,{children:"signOutUser"})," method in the ",(0,i.jsx)(n.code,{children:"UserAuthentication"})," class. The method removes all auth tokens associated with the user."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"class AuthenticatedEndpoint extends Endpoint {\n  @override\n  bool get requireLogin => true;\n  Future<void> logout(Session session) async {\n    await session.auth.signOutUser();\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In the above example, the ",(0,i.jsx)(n.code,{children:"logout"})," endpoint removes all auth tokens associated with the user. The user is then signed out and loses access to any protected endpoints."]}),"\n",(0,i.jsx)(n.h4,{id:"remove-specific-tokens",children:"Remove specific tokens"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"AuthKey"})," table stores all auth tokens and can be interacted with in the same way as any other model with a database in Serverpod. To remove specific tokens, the ",(0,i.jsx)(n.code,{children:"AuthKey"})," table can be interacted with directly."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"await AuthKey.db.deleteWhere(\n  session,\n  where: (t) => t.userId.equals(userId) & t.method.equals('username'),\n);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In the above example, all auth tokens associated with the user ",(0,i.jsx)(n.code,{children:"userId"})," and created with the method ",(0,i.jsx)(n.code,{children:"username"})," are removed from the ",(0,i.jsx)(n.code,{children:"AuthKey"})," table."]}),"\n",(0,i.jsx)(n.h4,{id:"custom-token-solution",children:"Custom token solution"}),"\n",(0,i.jsxs)(n.p,{children:["If a ",(0,i.jsx)(n.a,{href:"#custom-auth-tokens",children:"custom auth token"})," solution has been implemented, auth token removal must be handled manually. The ",(0,i.jsx)(n.code,{children:"signOutUser"})," method does not provide an interface to interact with other database tables."]}),"\n",(0,i.jsx)(n.h2,{id:"client-setup",children:"Client setup"}),"\n",(0,i.jsx)(n.p,{children:"Enabling authentication in the client is as simple as configuring a key manager and placing any token in it. If a key manager is configured, the client will automatically query the manager for a token and include it in communication with the server."}),"\n",(0,i.jsx)(n.h3,{id:"configure-key-manager",children:"Configure key manager"}),"\n",(0,i.jsxs)(n.p,{children:["Key managers need to implement the ",(0,i.jsx)(n.code,{children:"AuthenticationKeyManager"})," interface. The key manager is configured when creating the client by passing it as the named parameter ",(0,i.jsx)(n.code,{children:"authenticationKeyManager"}),". If no key manager is configured, the client will not include tokens in requests to the server."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"class SimpleAuthKeyManager extends AuthenticationKeyManager {\n  String? _key;\n\n  @override\n  Future<String?> get() async {\n    return _key;\n  }\n\n  @override\n  Future<void> put(String key) async {\n    _key = key;\n  }\n\n  @override\n  Future<void> remove() async {\n    _key = null;\n  }\n}\n\n\nvar client = Client('http://$localhost:8080/',\n    authenticationKeyManager: SimpleAuthKeyManager())\n  ..connectivityMonitor = FlutterConnectivityMonitor();\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In the above example, the ",(0,i.jsx)(n.code,{children:"SimpleAuthKeyManager"})," is configured as the client's authentication key manager. The ",(0,i.jsx)(n.code,{children:"SimpleAuthKeyManager"})," stores the token in memory."]}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"SimpleAuthKeyManager"})," is not practical and should only be used for testing. A secure implementation of the key manager is available in the ",(0,i.jsx)(n.code,{children:"serverpod_auth_shared_flutter"})," package named ",(0,i.jsx)(n.code,{children:"FlutterAuthenticationKeyManager"}),". It provides safe, persistent storage for the auth token."]})}),"\n",(0,i.jsxs)(n.p,{children:["The key manager is then available through the client's ",(0,i.jsx)(n.code,{children:"authenticationKeyManager"})," field."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"var keyManager = client.authenticationKeyManager;\n"})}),"\n",(0,i.jsx)(n.h3,{id:"store-token",children:"Store token"}),"\n",(0,i.jsxs)(n.p,{children:["When the client receives a token from the server, it is responsible for storing it in the key manager using the ",(0,i.jsx)(n.code,{children:"put"})," method. The key manager will then include the token in all requests to the server."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"await client.authenticationKeyManager?.put(token);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In the above example, the ",(0,i.jsx)(n.code,{children:"token"})," is placed in the key manager. It will now be included in communication with the server."]}),"\n",(0,i.jsx)(n.h3,{id:"remove-token",children:"Remove token"}),"\n",(0,i.jsxs)(n.p,{children:["To remove the token from the key manager, call the ",(0,i.jsx)(n.code,{children:"remove"})," method."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"await client.authenticationKeyManager?.remove();\n"})}),"\n",(0,i.jsx)(n.p,{children:"The above example removes any token from the key manager."}),"\n",(0,i.jsx)(n.h3,{id:"retrieve-token",children:"Retrieve token"}),"\n",(0,i.jsxs)(n.p,{children:["To retrieve the token from the key manager, call the ",(0,i.jsx)(n.code,{children:"get"})," method."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"var token = await client.authenticationKeyManager?.get();\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The above example retrieves the token from the key manager and stores it in the ",(0,i.jsx)(n.code,{children:"token"})," variable."]})]})}function l(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},11151:(e,n,t)=>{t.d(n,{Z:()=>r,a:()=>s});var i=t(67294);const o={},a=i.createContext(o);function s(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);