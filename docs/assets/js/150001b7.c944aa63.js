"use strict";(self.webpackChunkserverpod_docs=self.webpackChunkserverpod_docs||[]).push([[19297],{90205:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"concepts/scheduling/inheritance","title":"Inheritance","description":"Inheritance gives you the possibility to modify the behavior of FutureCall classes defined in other Serverpod modules. If the parent FutureCall class was marked as abstract, no code is generated for it.","source":"@site/versioned_docs/version-3.2.0/06-concepts/14-scheduling/03-inheritance.md","sourceDirName":"06-concepts/14-scheduling","slug":"/concepts/scheduling/inheritance","permalink":"/concepts/scheduling/inheritance","draft":false,"unlisted":false,"editUrl":"https://github.com/serverpod/serverpod_docs/tree/main/versioned_docs/version-3.2.0/06-concepts/14-scheduling/03-inheritance.md","tags":[],"version":"3.2.0","sidebarPosition":3,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Recurring Task","permalink":"/concepts/scheduling/recurring-task"},"next":{"title":"Configuration","permalink":"/concepts/scheduling/configuration"}}');var t=n(74848),i=n(28453);const o={},a="Inheritance",c={},l=[{value:"Inheriting from a <code>FutureCall</code> class",id:"inheriting-from-a-futurecall-class",level:2},{value:"Inheriting from a <code>FutureCall</code> class marked <code>abstract</code>",id:"inheriting-from-a-futurecall-class-marked-abstract",level:2},{value:"Extending an <code>abstract</code> <code>FutureCall</code> class",id:"extending-an-abstract-futurecall-class",level:3},{value:"Overriding future call methods",id:"overriding-future-call-methods",level:3}];function d(e){const s={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.header,{children:(0,t.jsx)(s.h1,{id:"inheritance",children:"Inheritance"})}),"\n",(0,t.jsxs)(s.p,{children:["Inheritance gives you the possibility to modify the behavior of ",(0,t.jsx)(s.code,{children:"FutureCall"})," classes defined in other Serverpod modules. If the parent ",(0,t.jsx)(s.code,{children:"FutureCall"})," class was marked as ",(0,t.jsx)(s.code,{children:"abstract"}),", no code is generated for it."]}),"\n",(0,t.jsxs)(s.p,{children:["Currently, there are the following possibilities to extend another ",(0,t.jsx)(s.code,{children:"FutureCall"})," class:"]}),"\n",(0,t.jsxs)(s.h2,{id:"inheriting-from-a-futurecall-class",children:["Inheriting from a ",(0,t.jsx)(s.code,{children:"FutureCall"})," class"]}),"\n",(0,t.jsxs)(s.p,{children:["Given an existing ",(0,t.jsx)(s.code,{children:"FutureCall"})," class, it is possible to extend or modify its behavior while retaining the already exposed methods."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-dart",children:"import 'package:serverpod/serverpod.dart';\n\nclass Greeter extends FutureCall {\n  Future<void> hello(Session session, String name) async {\n    session.log('Hello $name');\n  }\n}\n\nclass MyGreeter extends Greeter {\n  Future<void> bye(Session session, String name) async {\n    session.log('Bye $name');\n  }\n}\n"})}),"\n",(0,t.jsxs)(s.p,{children:["The generated server code will now be able to access both ",(0,t.jsx)(s.code,{children:"Greeter"})," and ",(0,t.jsx)(s.code,{children:"MyGreeter"}),".\nWhereas the ",(0,t.jsx)(s.code,{children:"Greeter"})," only exposes the original ",(0,t.jsx)(s.code,{children:"hello"})," method, ",(0,t.jsx)(s.code,{children:"MyGreeter"})," now exposes both the inherited ",(0,t.jsx)(s.code,{children:"hello"})," and its own ",(0,t.jsx)(s.code,{children:"bye"})," methods."]}),"\n",(0,t.jsxs)(s.h2,{id:"inheriting-from-a-futurecall-class-marked-abstract",children:["Inheriting from a ",(0,t.jsx)(s.code,{children:"FutureCall"})," class marked ",(0,t.jsx)(s.code,{children:"abstract"})]}),"\n",(0,t.jsxs)(s.p,{children:["Future calls marked as ",(0,t.jsx)(s.code,{children:"abstract"})," are not added to the server. But if they are subclassed, their methods will be exposed through the subclass."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-dart",children:"import 'package:serverpod/serverpod.dart';\n\nabstract class Greeter extends FutureCall {\n  Future<void> hello(Session session, String name) async {\n    session.log('Hello $name');\n  }\n}\n\nclass MyGreeter extends Greeter {}\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Since ",(0,t.jsx)(s.code,{children:"Greeter"})," is ",(0,t.jsx)(s.code,{children:"abstract"}),", it will not be added to the server. However, ",(0,t.jsx)(s.code,{children:"MyGreeter"})," will expose a single ",(0,t.jsx)(s.code,{children:"hello"})," method."]}),"\n",(0,t.jsx)(s.admonition,{type:"info",children:(0,t.jsxs)(s.p,{children:["Serverpod modules can expose future calls to users with ",(0,t.jsx)(s.code,{children:"abstract"})," ",(0,t.jsx)(s.code,{children:"FutureCall"}),". Code is only generated on the current project that extends the abstract future call."]})}),"\n",(0,t.jsxs)(s.h3,{id:"extending-an-abstract-futurecall-class",children:["Extending an ",(0,t.jsx)(s.code,{children:"abstract"})," ",(0,t.jsx)(s.code,{children:"FutureCall"})," class"]}),"\n",(0,t.jsxs)(s.p,{children:["In the above example, the ",(0,t.jsx)(s.code,{children:"MyGreeter"})," only exposed the inherited ",(0,t.jsx)(s.code,{children:"hello"})," method. It can be further extended with custom methods like this:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-dart",children:"import 'package:serverpod/serverpod.dart';\n\nclass MyGreeter extends Greeter {\n  Future<void> bye(Session session, String name) async {\n    session.log('Bye $name');\n  }\n}\n"})}),"\n",(0,t.jsxs)(s.p,{children:["In this case, it will expose both a ",(0,t.jsx)(s.code,{children:"hello"})," and a ",(0,t.jsx)(s.code,{children:"bye"})," method."]}),"\n",(0,t.jsx)(s.h3,{id:"overriding-future-call-methods",children:"Overriding future call methods"}),"\n",(0,t.jsx)(s.p,{children:"It is possible to override methods of the superclass. This can be useful when you want to modify the behavior of specific methods but preserve the rest."}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-dart",children:"import 'package:serverpod/serverpod.dart';\n\nabstract class Greeter extends FutureCall {\n  Future<void> hello(Session session, String name) async {\n    session.log('Hello $name');\n  }\n}\n\nclass ExcitedGreeter extends Greeter {\n  @override\n  Future<void> hello(Session session, String name) async {\n    session.log('Hello $name!!!');\n  }\n}\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Since ",(0,t.jsx)(s.code,{children:"Greeter"})," is ",(0,t.jsx)(s.code,{children:"abstract"}),", it will not be exposed on the server. The ",(0,t.jsx)(s.code,{children:"ExcitedGreeter"})," will expose a single ",(0,t.jsx)(s.code,{children:"hello"})," method, and its implementation will augment the superclass's one by adding ",(0,t.jsx)(s.code,{children:"!!!"})," to the output."]}),"\n",(0,t.jsxs)(s.p,{children:["This way, you can modify the behavior of future call methods while still sharing the implementation through calls to ",(0,t.jsx)(s.code,{children:"super"}),". Be aware that the method signature has to be compatible with the base class per Dart's rules, meaning you can add optional parameters, but can not add required parameters or change the return type."]})]})}function h(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,s,n)=>{n.d(s,{R:()=>o,x:()=>a});var r=n(96540);const t={},i=r.createContext(t);function o(e){const s=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),r.createElement(i.Provider,{value:s},e.children)}}}]);