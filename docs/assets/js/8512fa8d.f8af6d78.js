"use strict";(self.webpackChunkserverpod_docs=self.webpackChunkserverpod_docs||[]).push([[9364],{1229:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"get-started/working-with-the-database","title":"Working with the database","description":"In this section, we will build upon the models we created in the previous section and add a database to store the recipes that users create in the app. This will allow our application to persist data between sessions.","source":"@site/docs/01-get-started/03-working-with-the-database.md","sourceDirName":"01-get-started","slug":"/get-started/working-with-the-database","permalink":"/next/get-started/working-with-the-database","draft":false,"unlisted":false,"editUrl":"https://github.com/serverpod/serverpod_docs/tree/main/docs/01-get-started/03-working-with-the-database.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_label":"3. Working with the database"},"sidebar":"tutorialSidebar","previous":{"title":"2. Models and data","permalink":"/next/get-started/models-and-data"},"next":{"title":"4. Deploying Serverpod","permalink":"/next/get-started/deployment"}}');var r=t(74848),a=t(28453);const s={sidebar_label:"3. Working with the database"},o="Working with the database",d={},l=[{value:"Object relation mapping",id:"object-relation-mapping",level:2},{value:"Migrations",id:"migrations",level:2},{value:"Writing to the database",id:"writing-to-the-database",level:2},{value:"Reading from the database",id:"reading-from-the-database",level:2},{value:"Generate the code",id:"generate-the-code",level:2},{value:"Call the endpoint from the app",id:"call-the-endpoint-from-the-app",level:2},{value:"Run the app",id:"run-the-app",level:2},{value:"Summary",id:"summary",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components},{Details:i}=n;return i||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"working-with-the-database",children:"Working with the database"})}),"\n",(0,r.jsx)(n.p,{children:"In this section, we will build upon the models we created in the previous section and add a database to store the recipes that users create in the app. This will allow our application to persist data between sessions."}),"\n",(0,r.jsx)(n.h2,{id:"object-relation-mapping",children:"Object relation mapping"}),"\n",(0,r.jsxs)(n.p,{children:["Any Serverpod model can be mapped to the database through Serverpod's object relation mapping (ORM). To enable database storage for our recipe model, simply add the ",(0,r.jsx)(n.code,{children:"table"})," keyword to the ",(0,r.jsx)(n.code,{children:"Recipe"})," model in our ",(0,r.jsx)(n.code,{children:"recipe.spy.yaml"})," file. This will map the model to a new table in the database called ",(0,r.jsx)(n.code,{children:"recipes"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"### Our AI generated Recipe\nclass: Recipe\ntable: recipes\nfields:\n  ### The author of the recipe\n  author: String\n  ### The recipe text\n  text: String\n  ### The date the recipe was created\n  date: DateTime\n  ### The ingredients the user has passed in\n  ingredients: String\n"})}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsxs)(n.p,{children:["Check out the reference for ",(0,r.jsx)(n.a,{href:"/next/concepts/models#keywords-1",children:"database models"})," for an overview of all available keywords."]})}),"\n",(0,r.jsx)(n.h2,{id:"migrations",children:"Migrations"}),"\n",(0,r.jsx)(n.p,{children:"Database migrations in Serverpod provide a way to safely evolve your database schema over time. When you make changes to your models that affect the database structure, you need to create a migration. A migration consists of SQL queries that update the database schema to match your model changes."}),"\n",(0,r.jsx)(n.p,{children:"To create a migration, follow these two steps in order:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Run ",(0,r.jsx)(n.code,{children:"serverpod generate"})," to update the generated code based on your model changes."]}),"\n",(0,r.jsxs)(n.li,{children:["Run ",(0,r.jsx)(n.code,{children:"serverpod create-migration"})," to create the necessary database migration."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"$ cd magic_recipe/magic_recipe_server\n$ serverpod generate\n$ serverpod create-migration\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Each time you run ",(0,r.jsx)(n.code,{children:"serverpod create-migration"}),", a new migration file will be created in your ",(0,r.jsx)(n.em,{children:"migrations"})," folder. These step-by-step migrations provide a history of your database changes and allow you to roll back changes if needed."]}),"\n",(0,r.jsx)(n.h2,{id:"writing-to-the-database",children:"Writing to the database"}),"\n",(0,r.jsxs)(n.p,{children:["Now that we've added the ",(0,r.jsx)(n.code,{children:"table"})," keyword to our ",(0,r.jsx)(n.code,{children:"Recipe"})," model, it becomes a ",(0,r.jsx)(n.code,{children:"TableRow"})," type, giving us access to database operations. Serverpod automatically generates database bindings that we can access through the static ",(0,r.jsx)(n.code,{children:"db"})," field of the ",(0,r.jsx)(n.code,{children:"Recipe"})," class. Let's use the ",(0,r.jsx)(n.code,{children:"insertRow"})," method to save new recipes to the database:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"// ...\nclass RecipeEndpoint extends Endpoint {\n  /// Pass in a string containing the ingredients and get a recipe back.\n  Future<Recipe> generateRecipe(Session session, String ingredients) async {\n// ...\n    final recipe = Recipe(\n      author: 'Gemini',\n      text: responseText,\n      date: DateTime.now(),\n      ingredients: ingredients,\n    );\n\n    // Save the recipe to the database, the returned recipe has the id set\n    final recipeWithId = await Recipe.db.insertRow(session, recipe);\n\n    return recipeWithId;\n  }\n\n"})}),"\n",(0,r.jsx)(n.h2,{id:"reading-from-the-database",children:"Reading from the database"}),"\n",(0,r.jsxs)(n.p,{children:["Next, let's add a new method to the ",(0,r.jsx)(n.code,{children:"RecipeEndpoint"})," class that will return all the recipes that we have created and saved to the database."]}),"\n",(0,r.jsx)(n.p,{children:"To make sure that we get them in the correct order, we sort them by the date they were created."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"// ...\nclass RecipeEndpoint extends Endpoint {\n  /// Pass in a string containing the ingredients and get a recipe back.\n  Future<Recipe> generateRecipe(Session session, String ingredients) async {\n// ...\n  /// This method returns all the generated recipes from the database.\n  Future<List<Recipe>> getRecipes(Session session) async {\n    // Get all the recipes from the database, sorted by date.\n    return Recipe.db.find(\n      session,\n      orderBy: (t) => t.date,\n      orderDescending: true,\n    );\n  }\n}\n"})}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsx)("summary",{children:"Click to see the full code"}),(0,r.jsx)("p",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"import 'dart:async';\n\nimport 'package:google_generative_ai/google_generative_ai.dart';\nimport 'package:magic_recipe_server/src/generated/protocol.dart';\nimport 'package:serverpod/serverpod.dart';\n\n/// This is the endpoint that will be used to generate a recipe using the\n/// Google Gemini API. It extends the Endpoint class and implements the\n/// generateRecipe method.\nclass RecipeEndpoint extends Endpoint {\n  /// Pass in a string containing the ingredients and get a recipe back.\n  Future<Recipe> generateRecipe(Session session, String ingredients) async {\n    // Serverpod automatically loads your passwords.yaml file and makes the passwords available\n    // in the session.passwords map.\n    final geminiApiKey = session.passwords['gemini'];\n    if (geminiApiKey == null) {\n      throw Exception('Gemini API key not found');\n    }\n    final gemini = GenerativeModel(\n      model: 'gemini-1.5-flash-latest',\n      apiKey: geminiApiKey,\n    );\n\n    // A prompt to generate a recipe, the user will provide a free text input with the ingredients\n    final prompt =\n        'Generate a recipe using the following ingredients: $ingredients, always put the title '\n        'of the recipe in the first line, and then the instructions. The recipe should be easy '\n        'to follow and include all necessary steps. Please provide a detailed recipe.';\n\n    final response = await gemini.generateContent([Content.text(prompt)]);\n\n    final responseText = response.text;\n\n    // Check if the response is empty or null\n    if (responseText == null || responseText.isEmpty) {\n      throw Exception('No response from Gemini API');\n    }\n\n    final recipe = Recipe(\n      author: 'Gemini',\n      text: responseText,\n      date: DateTime.now(),\n      ingredients: ingredients,\n    );\n\n    // Save the recipe to the database, the returned recipe has the id set\n    final recipeWithId = await Recipe.db.insertRow(session, recipe);\n\n    return recipeWithId;\n  }\n\n  /// This method returns all the generated recipes from the database.\n  Future<List<Recipe>> getRecipes(Session session) async {\n    // Get all the recipes from the database, sorted by date.\n    return Recipe.db.find(\n      session,\n      orderBy: (t) => t.date,\n      orderDescending: true,\n    );\n  }\n}\n"})})})]}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsxs)(n.p,{children:["The when adding a ",(0,r.jsx)(n.code,{children:"table"})," to the model class definition, the model will now give you access to the database, specifically to the ",(0,r.jsx)(n.code,{children:"recipes"})," table through ",(0,r.jsx)(n.code,{children:"Recipe.db"})," (e.g. ",(0,r.jsx)(n.code,{children:"Recipe.db.find(session)"}),".\nThe ",(0,r.jsx)(n.code,{children:"insertRow"})," method is used to insert a new row in the database. The ",(0,r.jsx)(n.code,{children:"find"})," method is used to query the database and get all the rows of a specific type. See ",(0,r.jsx)(n.a,{href:"/next/concepts/database/crud",children:"CRUD"})," and ",(0,r.jsx)(n.a,{href:"/next/concepts/database/relation-queries",children:"relation queries"})," for more information."]})}),"\n",(0,r.jsx)(n.h2,{id:"generate-the-code",children:"Generate the code"}),"\n",(0,r.jsxs)(n.p,{children:["Like before, when you change something that has an effect on the client code, you need to run ",(0,r.jsx)(n.code,{children:"serverpod generate"}),". We don't need to run ",(0,r.jsx)(n.code,{children:"serverpod create-migrations"})," again because we already created a migration in the previous step and haven't done any changes that affect the database."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"$ cd magic_recipe/magic_recipe_server\n$ serverpod generate\n"})}),"\n",(0,r.jsx)(n.h2,{id:"call-the-endpoint-from-the-app",children:"Call the endpoint from the app"}),"\n",(0,r.jsxs)(n.p,{children:["Now that we have updated the endpoint, we can call it from the app. We do this in the ",(0,r.jsx)(n.code,{children:"magic_recipe_flutter/lib/main.dart"})," file. We will call the ",(0,r.jsx)(n.code,{children:"getRecipes"})," method when the app starts and store the result in a list of ",(0,r.jsx)(n.code,{children:"Recipe"})," objects. We will also update the UI to show the list of recipes."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"Final result",src:t(9671).A+"",width:"2352",height:"1460"})}),"\n",(0,r.jsxs)(n.p,{children:["If you want to see what changed, we suggest to creating a git commit now and then replacing the code in the ",(0,r.jsx)(n.code,{children:"main.dart"})," file."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"import 'package:magic_recipe_client/magic_recipe_client.dart';\nimport 'package:flutter/material.dart';\nimport 'package:serverpod_flutter/serverpod_flutter.dart';\n\n/// Sets up a global client object that can be used to talk to the server from\n/// anywhere in our app. The client is generated from your server code\n/// and is set up to connect to a Serverpod running on a local server on\n/// the default port. You will need to modify this to connect to staging or\n/// production servers.\n/// In a larger app, you may want to use the dependency injection of your choice instead of\n/// using a global client object. This is just a simple example.\nlate final Client client;\n\nlate String serverUrl;\n\nvoid main() {\n  // When you are running the app on a physical device, you need to set the\n  // server URL to the IP address of your computer. You can find the IP\n  // address by running `ipconfig` on Windows or `ifconfig` on Mac/Linux.\n  // You can set the variable when running or building your app like this:\n  // E.g. `flutter run --dart-define=SERVER_URL=https://api.example.com/`\n  const serverUrlFromEnv = String.fromEnvironment('SERVER_URL');\n  final serverUrl =\n      serverUrlFromEnv.isEmpty ? 'http://$localhost:8080/' : serverUrlFromEnv;\n\n  client = Client(serverUrl)\n    ..connectivityMonitor = FlutterConnectivityMonitor();\n\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Serverpod Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: const MyHomePage(title: 'Serverpod Example'),\n    );\n  }\n}\n\nclass MyHomePage extends StatefulWidget {\n  const MyHomePage({super.key, required this.title});\n\n  final String title;\n\n  @override\n  MyHomePageState createState() => MyHomePageState();\n}\n\nclass MyHomePageState extends State<MyHomePage> {\n  /// Holds the last result or null if no result exists yet.\n  Recipe? _recipe;\n\n  List<Recipe> _recipeHistory = [];\n\n  /// Holds the last error message that we've received from the server or null if no\n  /// error exists yet.\n  String? _errorMessage;\n\n  final _textEditingController = TextEditingController();\n\n  bool _loading = false;\n\n  void _callGenerateRecipe() async {\n    try {\n      setState(() {\n        _errorMessage = null;\n        _recipe = null;\n        _loading = true;\n      });\n      final result =\n          await client.recipe.generateRecipe(_textEditingController.text);\n      setState(() {\n        _errorMessage = null;\n        _recipe = result;\n        _loading = false;\n        _recipeHistory.insert(0, result);\n      });\n    } catch (e) {\n      setState(() {\n        _errorMessage = '$e';\n        _recipe = null;\n        _loading = false;\n      });\n    }\n  }\n\n  @override\n  void initState() {\n    super.initState();\n    // Get the favourite recipes from the database\n    client.recipe.getRecipes().then((favouriteRecipes) {\n      setState(() {\n        _recipeHistory = favouriteRecipes;\n      });\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(widget.title),\n      ),\n      body: Row(\n        children: [\n          Expanded(\n            child: DecoratedBox(\n              decoration: BoxDecoration(color: Colors.grey[300]),\n              child: ListView.builder(\n                itemCount: _recipeHistory.length,\n                itemBuilder: (context, index) {\n                  final recipe = _recipeHistory[index];\n                  return ListTile(\n                    title: Text(\n                        recipe.text.substring(0, recipe.text.indexOf('\\n'))),\n                    subtitle: Text('${recipe.author} - ${recipe.date}'),\n                    onTap: () {\n                      // Show the recipe in the text field\n                      _textEditingController.text = recipe.ingredients;\n                      setState(() {\n                        _recipe = recipe;\n                      });\n                    },\n                  );\n                },\n              ),\n            ),\n          ),\n          Expanded(\n            flex: 3,\n            child: Padding(\n              padding: const EdgeInsets.all(16),\n              child: Column(\n                children: [\n                  Padding(\n                    padding: const EdgeInsets.only(bottom: 16.0),\n                    child: TextField(\n                      controller: _textEditingController,\n                      decoration: const InputDecoration(\n                        hintText: 'Enter your ingredients',\n                      ),\n                    ),\n                  ),\n                  Padding(\n                    padding: const EdgeInsets.only(bottom: 16.0),\n                    child: ElevatedButton(\n                      onPressed: _loading ? null : _callGenerateRecipe,\n                      child: _loading\n                          ? const Text('Loading...')\n                          : const Text('Send to Server'),\n                    ),\n                  ),\n                  Expanded(\n                    child: SingleChildScrollView(\n                      child:\n                          // Change the ResultDisplay to use the Recipe object\n                          ResultDisplay(\n                        resultMessage: _recipe != null\n                            ? '${_recipe?.author} on ${_recipe?.date}:\\n${_recipe?.text}'\n                            : null,\n                        errorMessage: _errorMessage,\n                      ),\n                    ),\n                  ),\n                ],\n              ),\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n/// ResultDisplays shows the result of the call. Either the returned result from\n/// the `example.greeting` endpoint method or an error message.\nclass ResultDisplay extends StatelessWidget {\n  final String? resultMessage;\n  final String? errorMessage;\n\n  const ResultDisplay({\n    super.key,\n    this.resultMessage,\n    this.errorMessage,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    String text;\n    Color backgroundColor;\n    if (errorMessage != null) {\n      backgroundColor = Colors.red[300]!;\n      text = errorMessage!;\n    } else if (resultMessage != null) {\n      backgroundColor = Colors.green[300]!;\n      text = resultMessage!;\n    } else {\n      backgroundColor = Colors.grey[300]!;\n      text = 'No server response yet.';\n    }\n\n    return ConstrainedBox(\n      constraints: const BoxConstraints(minHeight: 50),\n      child: Container(\n        color: backgroundColor,\n        child: Center(\n          child: Text(text),\n        ),\n      ),\n    );\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"run-the-app",children:"Run the app"}),"\n",(0,r.jsx)(n.p,{children:"To run the application with database support, follow these steps in order:"}),"\n",(0,r.jsx)(n.p,{children:"First, start the database and apply migrations:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"$ cd magic_recipe/magic_recipe_server\n$ docker compose up -d                   # Start the database container\n$ dart bin/main.dart --apply-migrations  # Apply any pending migrations\n"})}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"--apply-migrations"})," flag is safe to use during development - if no migrations are pending, it will simply be ignored. For production environments, you may want more controlled migration management."]})}),"\n",(0,r.jsx)(n.p,{children:"Next, launch the Flutter app:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"$ cd magic_recipe/magic_recipe_flutter\n$ flutter run -d chrome\n"})}),"\n",(0,r.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(n.p,{children:"You've now learned the fundamentals of Serverpod:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Creating and using endpoints with custom data models."}),"\n",(0,r.jsx)(n.li,{children:"Storing data persistently in a database."}),"\n",(0,r.jsx)(n.li,{children:"Using the generated client code in your Flutter app."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["We're excited to see what you'll build with Flutter and Serverpod! If you need help, don't hesitate to ask questions in our ",(0,r.jsx)(n.a,{href:"https://github.com/serverpod/serverpod/discussions",children:"community on Github"}),". Both the Serverpod team and community members are active and ready to help."]}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsxs)(n.p,{children:["Database operations are a broad topic, and Serverpod's ORM offers many powerful features. To learn more about advanced database operations, check out the ",(0,r.jsx)(n.a,{href:"/next/concepts/database/connection",children:"Database"})," section."]})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},9671:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/final-result-29ad2849075b88f005d65c0d16279d1b.png"},28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var i=t(96540);const r={},a=i.createContext(r);function s(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);