"use strict";(globalThis.webpackChunkserverpod_docs=globalThis.webpackChunkserverpod_docs||[]).push([[28697],{39272(e,n,t){t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"concepts/authentication/token-managers/jwt-token-manager","title":"JWT Token Manager","description":"The JwtTokenManager uses JWT (JSON Web Tokens) for stateless authentication. This token manager provides:","source":"@site/docs/06-concepts/11-authentication/05-token-managers/02-jwt-token-manager.md","sourceDirName":"06-concepts/11-authentication/05-token-managers","slug":"/concepts/authentication/token-managers/jwt-token-manager","permalink":"/next/concepts/authentication/token-managers/jwt-token-manager","draft":false,"unlisted":false,"editUrl":"https://github.com/serverpod/serverpod_docs/tree/main/docs/06-concepts/11-authentication/05-token-managers/02-jwt-token-manager.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Managing tokens","permalink":"/next/concepts/authentication/token-managers/managing-tokens"},"next":{"title":"Server-side Sessions Token Manager","permalink":"/next/concepts/authentication/token-managers/server-side-sessions-token-manager"}}');var s=t(74848),a=t(28453);const r={},i="JWT Token Manager",c={},d=[{value:"Server-side configuration",id:"server-side-configuration",level:2},{value:"Basic configuration options",id:"basic-configuration-options",level:3},{value:"Token Algorithms",id:"token-algorithms",level:4},{value:"Extra configuration options",id:"extra-configuration-options",level:3},{value:"Attaching custom metadata to tokens",id:"attaching-custom-metadata-to-tokens",level:3},{value:"Attaching metadata when issuing tokens from an endpoint",id:"attaching-metadata-when-issuing-tokens-from-an-endpoint",level:4},{value:"Client-side configuration",id:"client-side-configuration",level:2}];function l(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"jwt-token-manager",children:"JWT Token Manager"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"JwtTokenManager"})," uses JWT (JSON Web Tokens) for stateless authentication. This token manager provides:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Stateless authentication (no database queries for validation)."}),"\n",(0,s.jsx)(n.li,{children:"Access tokens with short lifetimes."}),"\n",(0,s.jsx)(n.li,{children:"Refresh tokens for long-term authentication."}),"\n",(0,s.jsx)(n.li,{children:"Automatic token rotation."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"server-side-configuration",children:"Server-side configuration"}),"\n",(0,s.jsxs)(n.p,{children:["This token manager is created by passing a ",(0,s.jsx)(n.code,{children:"JwtConfig"})," object to the ",(0,s.jsx)(n.code,{children:"pod.initializeAuthServices()"})," as a ",(0,s.jsx)(n.code,{children:"tokenManagerBuilder"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"pod.initializeAuthServices(\n  tokenManagerBuilders: [\n    JwtConfig(\n      // The pepper used to hash the refresh token secret.\n      refreshTokenHashPepper: pod.getPassword(\n        'jwtRefreshTokenHashPepper',\n      )!,\n      // The algorithm used to sign the tokens.\n      algorithm: JwtAlgorithm.hmacSha512(\n        SecretKey(pod.getPassword('jwtHmacSha512PrivateKey')!),\n      ),\n    ),\n  ],\n);\n"})}),"\n",(0,s.jsxs)(n.admonition,{type:"tip",children:[(0,s.jsxs)(n.p,{children:["You can use the ",(0,s.jsx)(n.code,{children:"JwtConfigFromPasswords"})," constructor in replacement of the ",(0,s.jsx)(n.code,{children:"JwtConfig"})," above to automatically load the credentials from the ",(0,s.jsx)(n.code,{children:"config/passwords.yaml"})," file or environment variables. It will expect either the following keys on the file:"]}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"jwtRefreshTokenHashPepper"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"jwtHmacSha512PrivateKey"})}),"\n"]}),(0,s.jsx)(n.p,{children:"Or the following environment variables:"}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"SERVERPOD_PASSWORD_jwtRefreshTokenHashPepper"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"SERVERPOD_PASSWORD_jwtHmacSha512PrivateKey"})}),"\n"]})]}),"\n",(0,s.jsx)(n.p,{children:"Then, extend the abstract endpoint to expose it on the server:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"import 'package:serverpod_auth_idp_server/core.dart' as core;\n\nclass RefreshJwtTokensEndpoint extends core.RefreshJwtTokensEndpoint {}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Finally, run ",(0,s.jsx)(n.code,{children:"serverpod generate"})," to generate the client code and expose the endpoint on the server."]}),"\n",(0,s.jsx)(n.h3,{id:"basic-configuration-options",children:"Basic configuration options"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"algorithm"}),": Required. The algorithm to use for signing tokens (HMAC SHA-512 or ECDSA SHA-512)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"refreshTokenHashPepper"}),": Required. A secret pepper for hashing refresh tokens. Must be at least 10 characters long, but ",(0,s.jsx)(n.a,{href:"https://www.ietf.org/archive/id/draft-ietf-kitten-password-storage-04.html#name-storage-2",children:"the recommended length is 32 bytes"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"token-algorithms",children:"Token Algorithms"}),"\n",(0,s.jsx)(n.p,{children:"There are two supported token algorithms:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"HMAC SHA-512"}),": Use HMAC SHA-512 for symmetric key signing."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"algorithm: JwtAlgorithm.hmacSha512(\n  SecretKey(pod.getPassword('authenticationTokenPrivateKey')!),\n),\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"ECDSA SHA-512"}),": Use ECDSA SHA-512 for asymmetric key signing."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"algorithm: JwtAlgorithm.ecdsaSha512(\n  privateKey: ecPrivateKey,\n  publicKey: ecPublicKey,\n),\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["As of now, the ",(0,s.jsx)(n.code,{children:"JwtConfigFromPasswords"})," only supports HMAC SHA-512. To use ECDSA SHA-512, you need to pass the private and public keys manually."]}),"\n",(0,s.jsx)(n.h3,{id:"extra-configuration-options",children:"Extra configuration options"}),"\n",(0,s.jsxs)(n.p,{children:["Below is an example of a non-exhaustive list of some of the most common configuration options for the ",(0,s.jsx)(n.code,{children:"JwtTokenManager"}),". For more details on all options, check the ",(0,s.jsx)(n.code,{children:"JwtConfig"})," in-code documentation."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"final jwtConfig = JwtConfigFromPasswords(\n  // Optional: Set fallback algorithms for token verification\n  // This is useful for allowing old tokens to be validated after a rotation.\n  fallbackVerificationAlgorithms: [\n    JwtAlgorithm.hmacSha512(\n      SecretKey(pod.getPassword('fallbackJwtPrivateKey')!),\n    ),\n  ],\n  // Optional: Configure token lifetimes\n  accessTokenLifetime: Duration(minutes: 10),\n  refreshTokenLifetime: Duration(days: 14),\n  // Optional: Add custom claims to tokens.\n  // Claims will be included in every access token and sent with requests.\n  extraClaimsProvider: (session, context) async {\n    return {\n      'userRole': 'admin',\n      'organizationId': 'org-123',\n    };\n  },\n  // Check the [JwtConfig] documentation for more options.\n);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"attaching-custom-metadata-to-tokens",children:"Attaching custom metadata to tokens"}),"\n",(0,s.jsxs)(n.p,{children:["You can attach custom metadata to each JWT refresh token by providing an ",(0,s.jsx)(n.code,{children:"onRefreshTokenCreated"})," callback. This is useful for storing device information, IP address, user agent, or any other data you need to query or use later (for example, to list or revoke tokens by device). The callback runs when a refresh token is created, within the same transaction as the token insert."]}),"\n",(0,s.jsxs)(n.p,{children:["Define a server-only table that relates to ",(0,s.jsx)(n.code,{children:"RefreshToken"})," and store your metadata there. Example schema:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"class: TokenMetadata\nserverOnly: true\ntable: token_metadata\nfields:\n  ### The [RefreshToken] this metadata belongs to\n  refreshToken: module:serverpod_auth_core:RefreshToken?, relation(onDelete=Cascade)\n\n  ### The name of the token\n  name: String?\n\n  ### Device information for the token\n  deviceName: String?\n\n  ### IP address from which the token was created\n  ipAddress: String?\n\n  ### User agent string\n  userAgent: String?\n\nindexes:\n  refresh_token_id_unique_idx:\n    fields: refreshTokenId\n    unique: true\n"})}),"\n",(0,s.jsx)(n.p,{children:"Then configure the callback in your JWT config:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"JwtConfigFromPasswords(\n  onRefreshTokenCreated:\n      (\n        final session, {\n        required final authUserId,\n        required final refreshTokenId,\n        required final transaction,\n      }) async {\n        await TokenMetadata.db.insertRow(\n          session,\n          TokenMetadata(\n            refreshTokenId: refreshTokenId,\n            name: 'general-token',\n            ipAddress: session.request?.connectionInfo.remote.address.toString(),\n            userAgent: session.request?.headers.userAgent,\n          ),\n          transaction: transaction,\n        );\n      },\n),\n"})}),"\n",(0,s.jsxs)(n.p,{children:["To revoke tokens based on your custom metadata, query the metadata table for the token IDs you want to revoke and call ",(0,s.jsx)(n.code,{children:"revokeToken"})," for each:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"final tokenMetadata = await TokenMetadata.db.find(\n  session,\n  where: (final row) => row.deviceName.equals('Old Device'),\n);\n\nfor (final row in tokenMetadata) {\n  await AuthServices.instance.tokenManager.revokeToken(\n    session,\n    tokenId: row.refreshTokenId.toString(),\n  );\n}\n"})}),"\n",(0,s.jsx)(n.h4,{id:"attaching-metadata-when-issuing-tokens-from-an-endpoint",children:"Attaching metadata when issuing tokens from an endpoint"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"onRefreshTokenCreated"})," callback is global and runs for every new refresh token (including those created by identity providers). When you create a token from an endpoint\u2014for example, a personal access token (PAT) or CLI token\u2014you often have endpoint-specific parameters (e.g. a token name or label) that the callback cannot see. In that case, issue the token with ",(0,s.jsx)(n.code,{children:"AuthServices.instance.tokenManager.issueToken"}),", then use the returned ",(0,s.jsx)(n.code,{children:"AuthSuccess.jwtRefreshTokenId"})," to insert your metadata with the endpoint's parameters:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"final authSuccess = await AuthServices.instance.tokenManager.issueToken(\n  session,\n  authUserId: userId,\n  method: 'pat',\n  scopes: {Scope.admin},\n);\n\nawait TokenMetadata.db.insertRow(\n  session,\n  TokenMetadata(\n    refreshTokenId: authSuccess.jwtRefreshTokenId,\n    name: tokenName, // from your endpoint parameter\n    deviceName: deviceName, // from your endpoint parameter\n    ipAddress: session.request?.connectionInfo.remote.address.toString(),\n    userAgent: session.request?.headers.userAgent,\n  ),\n);\n"})}),"\n",(0,s.jsx)(n.h2,{id:"client-side-configuration",children:"Client-side configuration"}),"\n",(0,s.jsxs)(n.p,{children:["When using the ",(0,s.jsx)(n.code,{children:"JwtTokenManager"})," in the server, no extra configuration is needed on the client. It will automatically include the access token in requests to the server and eagerly refresh the token when it is 30 seconds away from expiring. In case the refresh token expires, the client will automatically sign the user out and redirect to the login page."]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},28453(e,n,t){t.d(n,{R:()=>r,x:()=>i});var o=t(96540);const s={},a=o.createContext(s);function r(e){const n=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),o.createElement(a.Provider,{value:n},e.children)}}}]);