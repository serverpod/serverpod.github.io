"use strict";(globalThis.webpackChunkserverpod_docs=globalThis.webpackChunkserverpod_docs||[]).push([[53357],{79368(e,t,s){s.r(t),s.d(t,{assets:()=>o,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>a,toc:()=>h});const a=JSON.parse('{"id":"concepts/caching","title":"Caching","description":"Accessing the database can be expensive for complex queries or if you need to run many different queries for a specific task. Serverpod makes it easy to cache frequently requested objects in the memory of your server. Any object can be cached, including primitive types (int, String, DateTime, Duration, ByteData, UuidValue), lists, maps, and serializable models. Objects can be stored in the Redis cache if your Serverpod is hosted across multiple servers in a cluster.","source":"@site/docs/06-concepts/08-caching.md","sourceDirName":"06-concepts","slug":"/concepts/caching","permalink":"/next/concepts/caching","draft":false,"unlisted":false,"editUrl":"https://github.com/serverpod/serverpod_docs/tree/main/docs/06-concepts/08-caching.md","tags":[],"version":"current","sidebarPosition":8,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Configurations","permalink":"/next/concepts/configuration"},"next":{"title":"Logging","permalink":"/next/concepts/logging"}}');var n=s(74848),c=s(28453);const i={},r="Caching",o={},h=[{value:"Caching objects",id:"caching-objects",level:2},{value:"Caching primitive objects",id:"caching-primitive-objects",level:3},{value:"Caching lists and collections",id:"caching-lists-and-collections",level:3},{value:"Cache miss handler",id:"cache-miss-handler",level:3}];function l(e){const t={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,c.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"caching",children:"Caching"})}),"\n",(0,n.jsx)(t.p,{children:"Accessing the database can be expensive for complex queries or if you need to run many different queries for a specific task. Serverpod makes it easy to cache frequently requested objects in the memory of your server. Any object can be cached, including primitive types (int, String, DateTime, Duration, ByteData, UuidValue), lists, maps, and serializable models. Objects can be stored in the Redis cache if your Serverpod is hosted across multiple servers in a cluster."}),"\n",(0,n.jsx)(t.admonition,{type:"info",children:(0,n.jsxs)(t.p,{children:["Objects must be serializable to be cached. Non-serializable objects will throw an error when attempting to cache them. Most Dart types are serializable, including primitives, collections, and custom objects with ",(0,n.jsx)(t.code,{children:"toJson"}),"/",(0,n.jsx)(t.code,{children:"fromJson"})," methods. All objects that can be used with endpoints or the database are supported."]})}),"\n",(0,n.jsx)(t.h2,{id:"caching-objects",children:"Caching objects"}),"\n",(0,n.jsxs)(t.p,{children:["Caches can be accessed through the ",(0,n.jsx)(t.code,{children:"Session"})," object. This is an example of an endpoint method for requesting data about a user:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-dart",children:"Future<UserData> getUserData(Session session, int userId) async {\n  // Define a unique key for the UserData object\n  var cacheKey = 'UserData-$userId';\n\n  // Try to retrieve the object from the cache\n  var userData = await session.caches.local.get<UserData>(cacheKey);\n\n  // If the object wasn't found in the cache, load it from the database and\n  // save it in the cache. Make it valid for 5 minutes.\n  if (userData == null) {\n    userData = UserData.db.findById(session, userId);\n    await session.caches.local.put(cacheKey, userData!, lifetime: Duration(minutes: 5));\n  }\n\n  // Return the user data to the client\n  return userData;\n}\n"})}),"\n",(0,n.jsx)(t.p,{children:"In total, there are three caches where you can store your objects. Two caches are local to the server handling the current session, and one is distributed across the server cluster through Redis. There are two variants for the local cache, one regular cache, and a priority cache. Place objects that are frequently accessed in the priority cache."}),"\n",(0,n.jsx)(t.p,{children:"Depending on the type and number of objects that are cached in the global cache, you may want to specify custom caching rules in Redis. This is currently not handled automatically by Serverpod."}),"\n",(0,n.jsx)(t.h3,{id:"caching-primitive-objects",children:"Caching primitive objects"}),"\n",(0,n.jsxs)(t.p,{children:["To cache primitive objects, simply call the ",(0,n.jsx)(t.code,{children:"put"})," method with the object. For the ",(0,n.jsx)(t.code,{children:"get"}),", specify the object type as the generic parameter, just like for ",(0,n.jsx)(t.code,{children:"SerializableModel"})," objects:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-dart",children:"await session.caches.local.put('userCount', 17, lifetime: Duration(minutes: 5));\n\nvar count = await session.caches.local.get<int>('userCount');\n"})}),"\n",(0,n.jsxs)(t.p,{children:["For ",(0,n.jsx)(t.code,{children:"DateTime"})," objects, it is recommended to always cache them as UTC. Otherwise, you may get unexpected results when retrieving the object from the cache."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-dart",children:"var lastUpdate = DateTime.now().toUtc();\n\nawait session.caches.local.put('lastUpdate', lastUpdate);\n\n// Retrieved `DateTime` object will always be in UTC.\nvar cached = await session.caches.local.get<DateTime>('lastUpdate');\n"})}),"\n",(0,n.jsx)(t.h3,{id:"caching-lists-and-collections",children:"Caching lists and collections"}),"\n",(0,n.jsx)(t.p,{children:"Lists and collections can also be cached directly:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-dart",children:"var users = [UserData(name: 'Alice'), UserData(name: 'Bob')];\n\nawait session.caches.local.put('users', users);\n\nvar cachedUsers = await session.caches.local.get<List<UserData>>('users');\n"})}),"\n",(0,n.jsx)(t.h3,{id:"cache-miss-handler",children:"Cache miss handler"}),"\n",(0,n.jsxs)(t.p,{children:["If you want to handle cache misses in a specific way, you can pass in a ",(0,n.jsx)(t.code,{children:"CacheMissHandler"})," to the ",(0,n.jsx)(t.code,{children:"get"})," method. The ",(0,n.jsx)(t.code,{children:"CacheMissHandler"})," makes it possible to store an object in the cache when a cache miss occurs."]}),"\n",(0,n.jsxs)(t.p,{children:["The above example rewritten using the ",(0,n.jsx)(t.code,{children:"CacheMissHandler"}),":"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-dart",children:"Future<UserData> getUserData(Session session, int userId) async {\n  // Define a unique key for the UserData object\n  var cacheKey = 'UserData-$userId';\n\n  // Try to retrieve the object from the cache\n  var userData = await session.caches.local.get(\n    cacheKey,\n    // If the object wasn't found in the cache, load it from the database and\n    // save it in the cache. Make it valid for 5 minutes.\n    CacheMissHandler(\n      () async => UserData.db.findById(session, userId),\n      lifetime: Duration(minutes: 5),\n    ),\n    );\n\n  // Return the user data to the client\n  return userData;\n}\n"})}),"\n",(0,n.jsxs)(t.p,{children:["If the ",(0,n.jsx)(t.code,{children:"CacheMissHandler"})," returns ",(0,n.jsx)(t.code,{children:"null"}),", no object will be stored in the cache."]})]})}function d(e={}){const{wrapper:t}={...(0,c.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},28453(e,t,s){s.d(t,{R:()=>i,x:()=>r});var a=s(96540);const n={},c=a.createContext(n);function i(e){const t=a.useContext(c);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),a.createElement(c.Provider,{value:t},e.children)}}}]);