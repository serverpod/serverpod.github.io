"use strict";(self.webpackChunkserverpod_docs=self.webpackChunkserverpod_docs||[]).push([[90049],{6759:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>r,default:()=>h,frontMatter:()=>d,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"concepts/working-with-endpoints","title":"Working with endpoints","description":"Endpoints are the connection points to the server from the client. With Serverpod, you add methods to your endpoint, and your client code will be generated to make the method call. For the code to be generated, you need to place the endpoint file anywhere under the lib directory of your server. Your endpoint should extend the Endpoint class. For methods to be generated, they need to return a typed Future, and its first argument should be a Session object. The Session object holds information about the call being made and provides access to the database.","source":"@site/docs/06-concepts/01-working-with-endpoints.md","sourceDirName":"06-concepts","slug":"/concepts/working-with-endpoints","permalink":"/next/concepts/working-with-endpoints","draft":false,"unlisted":false,"editUrl":"https://github.com/serverpod/serverpod_docs/tree/main/docs/06-concepts/01-working-with-endpoints.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Authentication","permalink":"/next/tutorials/guides/authentication"},"next":{"title":"Working with models","permalink":"/next/concepts/models"}}');var s=t(74848),o=t(28453);const d={},r="Working with endpoints",a={},c=[{value:"Passing parameters",id:"passing-parameters",level:2},{value:"Return types",id:"return-types",level:2},{value:"Ignore endpoint definition",id:"ignore-endpoint-definition",level:2},{value:"Ignore an entire <code>Endpoint</code> class",id:"ignore-an-entire-endpoint-class",level:3},{value:"Ignore individual <code>Endpoint</code> methods",id:"ignore-individual-endpoint-methods",level:3},{value:"Endpoint method inheritance",id:"endpoint-method-inheritance",level:2},{value:"Inheriting from an <code>Endpoint</code> class",id:"inheriting-from-an-endpoint-class",level:3},{value:"Inheriting from an <code>Endpoint</code> class marked <code>abstract</code>",id:"inheriting-from-an-endpoint-class-marked-abstract",level:3},{value:"Extending an <code>abstract</code> <code>Endpoint</code> class",id:"extending-an-abstract-endpoint-class",level:4},{value:"Inheriting from an <code>Endpoint</code> class annotated with <code>@doNotGenerate</code>",id:"inheriting-from-an-endpoint-class-annotated-with-donotgenerate",level:3},{value:"Overriding endpoint methods",id:"overriding-endpoint-methods",level:3},{value:"Hiding endpoint methods with <code>@doNotGenerate</code>",id:"hiding-endpoint-methods-with-donotgenerate",level:3},{value:"Unhiding endpoint methods annotated with <code>@doNotGenerate</code> in the super class",id:"unhiding-endpoint-methods-annotated-with-donotgenerate-in-the-super-class",level:3},{value:"Building base endpoints for behavior",id:"building-base-endpoints-for-behavior",level:3},{value:"Client-side endpoint inheritance",id:"client-side-endpoint-inheritance",level:2},{value:"Abstract endpoint client generation",id:"abstract-endpoint-client-generation",level:3},{value:"Using <code>getEndpointOfType</code> for type-safe endpoint access",id:"using-getendpointoftype-for-type-safe-endpoint-access",level:3},{value:"Disambiguating multiple endpoints",id:"disambiguating-multiple-endpoints",level:4},{value:"Use case: Module-provided abstract endpoints",id:"use-case-module-provided-abstract-endpoints",level:4}];function l(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"working-with-endpoints",children:"Working with endpoints"})}),"\n",(0,s.jsxs)(n.p,{children:["Endpoints are the connection points to the server from the client. With Serverpod, you add methods to your endpoint, and your client code will be generated to make the method call. For the code to be generated, you need to place the endpoint file anywhere under the ",(0,s.jsx)(n.code,{children:"lib"})," directory of your server. Your endpoint should extend the ",(0,s.jsx)(n.code,{children:"Endpoint"})," class. For methods to be generated, they need to return a typed ",(0,s.jsx)(n.code,{children:"Future"}),", and its first argument should be a ",(0,s.jsx)(n.code,{children:"Session"})," object. The ",(0,s.jsx)(n.code,{children:"Session"})," object holds information about the call being made and provides access to the database."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"import 'package:serverpod/serverpod.dart';\n\nclass ExampleEndpoint extends Endpoint {\n  Future<String> hello(Session session, String name) async {\n    return 'Hello $name';\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The above code will create an endpoint called ",(0,s.jsx)(n.code,{children:"example"})," (the Endpoint suffix will be removed) with the single ",(0,s.jsx)(n.code,{children:"hello"})," method. To generate the client-side code run ",(0,s.jsx)(n.code,{children:"serverpod generate"})," in the home directory of the server."]}),"\n",(0,s.jsx)(n.p,{children:"On the client side, you can now call the method by calling:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"var result = await client.example.hello('World');\n"})}),"\n",(0,s.jsx)(n.p,{children:"The client is initialized like this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"// Sets up a singleton client object that can be used to talk to the server from\n// anywhere in our app. The client is generated from your server code.\n// The client is set up to connect to a Serverpod running on a local server on\n// the default port. You will need to modify this to connect to staging or\n// production servers.\nvar client = Client('http://$localhost:8080/')\n  ..connectivityMonitor = FlutterConnectivityMonitor();\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If you run the app in an Android emulator, the ",(0,s.jsx)(n.code,{children:"localhost"})," parameter points to ",(0,s.jsx)(n.code,{children:"10.0.2.2"}),", rather than ",(0,s.jsx)(n.code,{children:"127.0.0.1"})," as this is the IP address of the host machine. To access the server from a different device on the same network (such as a physical phone) replace ",(0,s.jsx)(n.code,{children:"localhost"})," with the local ip address. You can find the local ip by running ",(0,s.jsx)(n.code,{children:"ifconfig"})," (Linux/MacOS) or ",(0,s.jsx)(n.code,{children:"ipconfig"})," (Windows)."]}),"\n",(0,s.jsxs)(n.p,{children:["Make sure to also update the ",(0,s.jsx)(n.code,{children:"publicHost"})," in the development config to make sure the server always serves the client with the correct path to assets etc."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"# your_project_server/config/development.yaml\n\napiServer:\n  port: 8080\n  publicHost: localhost # Change this line\n  publicPort: 8080\n  publicScheme: http\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["You can pass the ",(0,s.jsx)(n.code,{children:"--watch"})," flag to ",(0,s.jsx)(n.code,{children:"serverpod generate"})," to watch for changed files and generate code whenever your source files are updated. This is useful during the development of your server."]})}),"\n",(0,s.jsx)(n.h2,{id:"passing-parameters",children:"Passing parameters"}),"\n",(0,s.jsxs)(n.p,{children:["There are some limitations to how endpoint methods can be implemented. Parameters and return types can be of type ",(0,s.jsx)(n.code,{children:"bool"}),", ",(0,s.jsx)(n.code,{children:"int"}),", ",(0,s.jsx)(n.code,{children:"double"}),", ",(0,s.jsx)(n.code,{children:"String"}),", ",(0,s.jsx)(n.code,{children:"UuidValue"}),", ",(0,s.jsx)(n.code,{children:"Duration"}),", ",(0,s.jsx)(n.code,{children:"DateTime"}),", ",(0,s.jsx)(n.code,{children:"ByteData"}),", ",(0,s.jsx)(n.code,{children:"Uri"}),", ",(0,s.jsx)(n.code,{children:"BigInt"}),", or generated serializable objects (see next section). A typed ",(0,s.jsx)(n.code,{children:"Future"})," should always be returned. Null safety is supported. When passing a ",(0,s.jsx)(n.code,{children:"DateTime"})," it is always converted to UTC."]}),"\n",(0,s.jsxs)(n.p,{children:["You can also pass ",(0,s.jsx)(n.code,{children:"List"}),", ",(0,s.jsx)(n.code,{children:"Map"}),", ",(0,s.jsx)(n.code,{children:"Record"})," and ",(0,s.jsx)(n.code,{children:"Set"})," as parameters, but they need to be strictly typed with one of the types mentioned above."]}),"\n",(0,s.jsxs)(n.admonition,{type:"warning",children:[(0,s.jsxs)(n.p,{children:["While it's possible to pass binary data through a method call and ",(0,s.jsx)(n.code,{children:"ByteData"}),", it is not the most efficient way to transfer large files. See our ",(0,s.jsx)(n.a,{href:"file-uploads",children:"file upload"})," interface. The size of a call is by default limited to 512 kB. It's possible to change by adding the ",(0,s.jsx)(n.code,{children:"maxRequestSize"})," to your config files. E.g., this will double the request size to 1 MB:"]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"maxRequestSize: 1048576\n"})})]}),"\n",(0,s.jsx)(n.h2,{id:"return-types",children:"Return types"}),"\n",(0,s.jsx)(n.p,{children:"The return type must be a typed Future. Supported return types are the same as for parameters."}),"\n",(0,s.jsx)(n.h2,{id:"ignore-endpoint-definition",children:"Ignore endpoint definition"}),"\n",(0,s.jsxs)(n.h3,{id:"ignore-an-entire-endpoint-class",children:["Ignore an entire ",(0,s.jsx)(n.code,{children:"Endpoint"})," class"]}),"\n",(0,s.jsxs)(n.p,{children:["If you want the code generator to ignore an endpoint definition, you can annotate either the entire class or individual methods with ",(0,s.jsx)(n.code,{children:"@doNotGenerate"}),". This can be useful if you want to keep the definition in your codebase without generating server or client bindings for it."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"import 'package:serverpod/serverpod.dart';\n\n@doNotGenerate\nclass ExampleEndpoint extends Endpoint {\n  Future<String> hello(Session session, String name) async {\n    return 'Hello $name';\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"The above code will not generate any server or client bindings for the example endpoint."}),"\n",(0,s.jsxs)(n.h3,{id:"ignore-individual-endpoint-methods",children:["Ignore individual ",(0,s.jsx)(n.code,{children:"Endpoint"})," methods"]}),"\n",(0,s.jsxs)(n.p,{children:["Alternatively, you can disable single methods by annotation them with ",(0,s.jsx)(n.code,{children:"@doNotGenerate"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"import 'package:serverpod/serverpod.dart';\n\nclass ExampleEndpoint extends Endpoint {\n  Future<String> hello(Session session, String name) async {\n    return 'Hello $name';\n  }\n\n  @doNotGenerate\n  Future<String> goodbye(Session session, String name) async {\n    return 'Bye $name';\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In this case the ",(0,s.jsx)(n.code,{children:"ExampleEndpoint"})," will only expose the ",(0,s.jsx)(n.code,{children:"hello"})," method, whereas the ",(0,s.jsx)(n.code,{children:"goodbye"})," method will not be accessible externally."]}),"\n",(0,s.jsx)(n.h2,{id:"endpoint-method-inheritance",children:"Endpoint method inheritance"}),"\n",(0,s.jsxs)(n.p,{children:["Endpoints can be based on other endpoints using inheritance, like ",(0,s.jsx)(n.code,{children:"class ChildEndpoint extends ParentEndpoint"}),". If the parent endpoint was marked as ",(0,s.jsx)(n.code,{children:"abstract"})," or ",(0,s.jsx)(n.code,{children:"@doNotGenerate"}),", no client code is generated for it, but a client will be generated for your subclass \u2013 as long as it does not opt out again.\nInheritance gives you the possibility to modify the behavior of ",(0,s.jsx)(n.code,{children:"Endpoint"})," classes defined in other Serverpod modules."]}),"\n",(0,s.jsxs)(n.p,{children:["Currently, there are the following possibilities to extend another ",(0,s.jsx)(n.code,{children:"Endpoint"})," class:"]}),"\n",(0,s.jsxs)(n.h3,{id:"inheriting-from-an-endpoint-class",children:["Inheriting from an ",(0,s.jsx)(n.code,{children:"Endpoint"})," class"]}),"\n",(0,s.jsxs)(n.p,{children:["Given an existing ",(0,s.jsx)(n.code,{children:"Endpoint"})," class, it is possible to extend or modify its behavior while retaining the already exposed methods."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"import 'package:serverpod/serverpod.dart';\n\nclass CalculatorEndpoint extends Endpoint {\n  Future<int> add(Session session, int a, int b) async {\n    return a + b;\n  }\n}\n\nclass MyCalculatorEndpoint extends CalculatorEndpoint {\n  Future<int> subtract(Session session, int a, int b) async {\n    return a - b;\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The generated client code will now be able to access both ",(0,s.jsx)(n.code,{children:"CalculatorEndpoint"})," and ",(0,s.jsx)(n.code,{children:"MyCalculatorEndpoint"}),".\nWhereas the ",(0,s.jsx)(n.code,{children:"CalculatorEndpoint"})," only exposes the original ",(0,s.jsx)(n.code,{children:"add"})," method, ",(0,s.jsx)(n.code,{children:"MyCalculatorEndpoint"})," now exposes both the inherited ",(0,s.jsx)(n.code,{children:"add"})," and its own ",(0,s.jsx)(n.code,{children:"subtract"})," methods."]}),"\n",(0,s.jsxs)(n.h3,{id:"inheriting-from-an-endpoint-class-marked-abstract",children:["Inheriting from an ",(0,s.jsx)(n.code,{children:"Endpoint"})," class marked ",(0,s.jsx)(n.code,{children:"abstract"})]}),"\n",(0,s.jsxs)(n.p,{children:["Endpoints marked as ",(0,s.jsx)(n.code,{children:"abstract"})," are not added to the server. But if they are subclassed, their methods will be exposed through the subclass."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"import 'package:serverpod/serverpod.dart';\n\nabstract class CalculatorEndpoint extends Endpoint {\n  Future<int> add(Session session, int a, int b) async {\n    return a + b;\n  }\n}\n\nclass MyCalculatorEndpoint extends CalculatorEndpoint {}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Since ",(0,s.jsx)(n.code,{children:"CalculatorEndpoint"})," is ",(0,s.jsx)(n.code,{children:"abstract"}),", it will not be exposed on the server. However, an abstract client class will be generated, which will be extended by the class generated from ",(0,s.jsx)(n.code,{children:"MyCalculatorEndpoint"}),". The concrete client exposes the ",(0,s.jsx)(n.code,{children:"add"})," method it inherited from ",(0,s.jsx)(n.code,{children:"CalculatorEndpoint"}),". See ",(0,s.jsx)(n.a,{href:"#client-side-endpoint-inheritance",children:"Client-side endpoint inheritance"})," for more details on how abstract endpoints are represented on the client."]}),"\n",(0,s.jsxs)(n.h4,{id:"extending-an-abstract-endpoint-class",children:["Extending an ",(0,s.jsx)(n.code,{children:"abstract"})," ",(0,s.jsx)(n.code,{children:"Endpoint"})," class"]}),"\n",(0,s.jsxs)(n.p,{children:["In the above example, the ",(0,s.jsx)(n.code,{children:"MyCalculatorEndpoint"})," only exposed the inherited ",(0,s.jsx)(n.code,{children:"add"})," method. It can be further extended with custom methods like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"import 'package:serverpod/serverpod.dart';\n\nclass MyCalculatorEndpoint extends CalculatorEndpoint {\n  Future<int> subtract(Session session, int a, int b) async {\n    return a - b;\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In this case, it will expose both an ",(0,s.jsx)(n.code,{children:"add"})," and a ",(0,s.jsx)(n.code,{children:"subtract"})," method."]}),"\n",(0,s.jsxs)(n.h3,{id:"inheriting-from-an-endpoint-class-annotated-with-donotgenerate",children:["Inheriting from an ",(0,s.jsx)(n.code,{children:"Endpoint"})," class annotated with ",(0,s.jsx)(n.code,{children:"@doNotGenerate"})]}),"\n",(0,s.jsxs)(n.p,{children:["Suppose you had an ",(0,s.jsx)(n.code,{children:"Endpoint"})," class marked with ",(0,s.jsx)(n.code,{children:"@doNotGenerate"})," and a subclass that extends it:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"import 'package:serverpod/serverpod.dart';\n\n@doNotGenerate\nclass CalculatorEndpoint extends Endpoint {\n  Future<int> add(Session session, int a, int b) async {\n    return a + b;\n  }\n}\n\nclass MyCalculatorEndpoint extends CalculatorEndpoint {}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Since ",(0,s.jsx)(n.code,{children:"CalculatorEndpoint"})," is marked as ",(0,s.jsx)(n.code,{children:"@doNotGenerate"}),", it will not be exposed on the server and no client class will be generated for it. Only ",(0,s.jsx)(n.code,{children:"MyCalculatorEndpoint"})," will be accessible from the client, which provides the inherited ",(0,s.jsx)(n.code,{children:"add"})," methods from its parent class. Unlike abstract endpoints, when a parent is marked with ",(0,s.jsx)(n.code,{children:"@doNotGenerate"}),", the generated client class will implement the base endpoint class directly rather than extending a generated abstract parent class."]}),"\n",(0,s.jsx)(n.h3,{id:"overriding-endpoint-methods",children:"Overriding endpoint methods"}),"\n",(0,s.jsx)(n.p,{children:"It is possible to override methods of the superclass. This can be useful when you want to modify the behavior of specific methods but preserve the rest."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"import 'package:serverpod/serverpod.dart';\n\nabstract class GreeterBaseEndpoint extends Endpoint {\n  Future<String> greet(Session session, String name) async {\n    return 'Hello $name';\n  }\n}\n\nclass ExcitedGreeterEndpoint extends GreeterBaseEndpoint {\n  @override\n  Future<String> greet(Session session, String name) async {\n    return '${super.hello(session, name)}!!!';\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Since ",(0,s.jsx)(n.code,{children:"GreeterBaseEndpoint"})," is ",(0,s.jsx)(n.code,{children:"abstract"}),", it will not be exposed on the server. The ",(0,s.jsx)(n.code,{children:"ExcitedGreeterEndpoint"})," will expose a single ",(0,s.jsx)(n.code,{children:"greet"})," method, and its implementation will augment the superclass's one by adding ",(0,s.jsx)(n.code,{children:"!!!"})," to that result."]}),"\n",(0,s.jsxs)(n.p,{children:["This way, you can modify the behavior of endpoint methods while still sharing the implementation through calls to ",(0,s.jsx)(n.code,{children:"super"}),". Be aware that the method signature has to be compatible with the base class per Dart's rules, meaning you can add optional parameters, but can not add required parameters or change the return type."]}),"\n",(0,s.jsxs)(n.h3,{id:"hiding-endpoint-methods-with-donotgenerate",children:["Hiding endpoint methods with ",(0,s.jsx)(n.code,{children:"@doNotGenerate"})]}),"\n",(0,s.jsxs)(n.p,{children:["In case you want to hide methods from an endpoint use ",(0,s.jsx)(n.code,{children:"@doNotGenerate"})," in the child class like so:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"import 'package:serverpod/serverpod.dart';\n\nabstract class CalculatorEndpoint extends Endpoint {\n  Future<int> add(Session session, int a, int b) async {\n    return a + b;\n  }\n\n  Future<int> subtract(Session session, int a, int b) async {\n    return a - b;\n  }\n}\n\nclass AdderEndpoint extends CalculatorEndpoint {\n  @doNotGenerate\n  Future<int> subtract(Session session, int a, int b) async {\n    throw UnimplementedError();\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Since ",(0,s.jsx)(n.code,{children:"CalculatorEndpoint"})," is ",(0,s.jsx)(n.code,{children:"abstract"}),", it will not be exposed on the server. ",(0,s.jsx)(n.code,{children:"AdderEndpoint"})," inherits all methods from its parent class, but since it opts to hide ",(0,s.jsx)(n.code,{children:"subtract"})," by annotating it with ",(0,s.jsx)(n.code,{children:"@doNotGenerate"})," only the ",(0,s.jsx)(n.code,{children:"add"})," method will be exposed.\nDon't worry about the exception in the ",(0,s.jsx)(n.code,{children:"subtract"})," implementation. That is only added to satisfy the Dart compiler \u2013 in practice, nothing will ever call this method on ",(0,s.jsx)(n.code,{children:"AdderEndpoint"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Hiding endpoints from a super class is only appropriate in case the parent ",(0,s.jsx)(n.code,{children:"class"})," is ",(0,s.jsx)(n.code,{children:"abstract"})," or annotated with ",(0,s.jsx)(n.code,{children:"@doNotGenerate"}),". Otherwise, the method that should be hidden on the child would still be accessible via the parent class."]}),"\n",(0,s.jsxs)(n.h3,{id:"unhiding-endpoint-methods-annotated-with-donotgenerate-in-the-super-class",children:["Unhiding endpoint methods annotated with ",(0,s.jsx)(n.code,{children:"@doNotGenerate"})," in the super class"]}),"\n",(0,s.jsxs)(n.p,{children:["The reverse of the previous example would be a base endpoint that has a method marked with ",(0,s.jsx)(n.code,{children:"@doNotGenerate"}),", which you now want to expose on the subclass."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"import 'package:serverpod/serverpod.dart';\n\nabstract class CalculatorEndpoint extends Endpoint {\n  Future<int> add(Session session, int a, int b) async {\n    return a + b;\n  }\n\n  // Ignored, as this expensive computation should not be exposed by default\n  @doNotGenerate\n  Future<BigInt> addBig(Session session, BigInt a, BigInt b) async {\n    return a + b;\n  }\n}\n\nclass MyCalculatorEndpoint extends CalculatorEndpoint {\n  @override\n  Future<BigInt> addBig(Session session, BigInt a, BigInt b) async {\n    return super.addBig(session, a, b);\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Since ",(0,s.jsx)(n.code,{children:"CalculatorEndpoint"})," is ",(0,s.jsx)(n.code,{children:"abstract"}),", it will not be exposed on the server. ",(0,s.jsx)(n.code,{children:"MyCalculatorEndpoint"})," will expose both the ",(0,s.jsx)(n.code,{children:"add"})," and ",(0,s.jsx)(n.code,{children:"addBig"})," methods, since ",(0,s.jsx)(n.code,{children:"addBig"})," was overridden and thus lost the ",(0,s.jsx)(n.code,{children:"@doNotGenerate"})," annotation."]}),"\n",(0,s.jsx)(n.h3,{id:"building-base-endpoints-for-behavior",children:"Building base endpoints for behavior"}),"\n",(0,s.jsxs)(n.p,{children:["Endpoint subclassing is not just useful to inherit (or hide) methods, it can also be used to pre-configure any other property of the ",(0,s.jsx)(n.code,{children:"Endpoint"})," class."]}),"\n",(0,s.jsx)(n.p,{children:"For example, you could define a base class that requires callers to be logged in:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"abstract class LoggedInEndpoint extends Endpoint {\n  @override\n  bool get requireLogin => true;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["And now every endpoint that extends ",(0,s.jsx)(n.code,{children:"LoggedInEndpoint"})," will check that the user is logged in."]}),"\n",(0,s.jsx)(n.p,{children:"Similarly, you could wrap up a specific set of required scopes in a base endpoint, which you can then easily use for the app's endpoints instead of repeating the scopes in each:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"abstract class AdminEndpoint extends Endpoint {\n  @override\n  Set<Scope> get requiredScopes => {Scope.admin};\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Again, just have your custom endpoint extend ",(0,s.jsx)(n.code,{children:"AdminEndpoint"})," and you can be sure that the user has the appropriate permissions."]}),"\n",(0,s.jsx)(n.h2,{id:"client-side-endpoint-inheritance",children:"Client-side endpoint inheritance"}),"\n",(0,s.jsx)(n.p,{children:"When you use endpoint inheritance on the server, Serverpod generates matching client-side classes that mirror your inheritance hierarchy. This allows you to write type-safe client code that works with abstract endpoint types."}),"\n",(0,s.jsx)(n.h3,{id:"abstract-endpoint-client-generation",children:"Abstract endpoint client generation"}),"\n",(0,s.jsx)(n.p,{children:"When you define an abstract endpoint on the server, Serverpod generates an abstract client endpoint class. This is particularly useful for module developers who want to provide base functionality that users can extend."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Server-side abstract endpoint:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"import 'package:serverpod/serverpod.dart';\n\nabstract class CalculatorEndpoint extends Endpoint {\n  Future<int> add(Session session, int a, int b) async {\n    return a + b;\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Generated client-side abstract class:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"abstract class EndpointCalculator extends EndpointRef {\n  EndpointCalculator(EndpointCaller caller) : super(caller);\n\n  Future<int> add(int a, int b);\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"When you extend this abstract endpoint in your server:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"class MyCalculatorEndpoint extends CalculatorEndpoint {\n  Future<int> subtract(Session session, int a, int b) async {\n    return a - b;\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"The generated client class will extend the abstract client class:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"class EndpointMyCalculator extends EndpointCalculator {\n  EndpointMyCalculator(EndpointCaller caller) : super(caller);\n\n  @override\n  String get name => 'myCalculator';\n\n  @override\n  Future<int> add(int a, int b) => caller.callServerEndpoint<int>(\n        'myCalculator',\n        'add',\n        {'a': a, 'b': b},\n      );\n\n  Future<int> subtract(int a, int b) => caller.callServerEndpoint<int>(\n        'myCalculator',\n        'subtract',\n        {'a': a, 'b': b},\n      );\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"using-getendpointoftype-for-type-safe-endpoint-access",children:["Using ",(0,s.jsx)(n.code,{children:"getEndpointOfType"})," for type-safe endpoint access"]}),"\n",(0,s.jsxs)(n.p,{children:["When working with abstract endpoints, you can use the ",(0,s.jsx)(n.code,{children:"getEndpointOfType"})," method to retrieve concrete endpoint instances by their type. This is especially useful when writing code that depends on abstract endpoint interfaces provided by modules."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"// Get an endpoint by its type\nvar calculator = client.getEndpointOfType<EndpointCalculator>();\n\n// Now you can call methods defined in the abstract base class\nvar result = await calculator.add(5, 3);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"getEndpointOfType"})," method will:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Return the single endpoint of the requested type if only one exists."}),"\n",(0,s.jsxs)(n.li,{children:["Throw ",(0,s.jsx)(n.code,{children:"ServerpodClientEndpointNotFound"})," if no endpoint of that type is found."]}),"\n",(0,s.jsxs)(n.li,{children:["Throw ",(0,s.jsx)(n.code,{children:"ServerpodClientMultipleEndpointsFound"})," if multiple endpoints of that type exist."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"disambiguating-multiple-endpoints",children:"Disambiguating multiple endpoints"}),"\n",(0,s.jsx)(n.p,{children:"If you have multiple concrete implementations of the same abstract endpoint, you can disambiguate by providing the endpoint name:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"// Server-side: Two implementations of the same abstract endpoint\nclass BasicCalculatorEndpoint extends CalculatorEndpoint {}\nclass AdvancedCalculatorEndpoint extends CalculatorEndpoint {\n  Future<int> multiply(Session session, int a, int b) async {\n    return a * b;\n  }\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"// Client-side: Specify which implementation you want\nvar basicCalc = client.getEndpointOfType<EndpointCalculator>('basicCalculator');\nvar advancedCalc = client.getEndpointOfType<EndpointCalculator>('advancedCalculator');\n"})}),"\n",(0,s.jsx)(n.h4,{id:"use-case-module-provided-abstract-endpoints",children:"Use case: Module-provided abstract endpoints"}),"\n",(0,s.jsx)(n.p,{children:"This pattern is particularly powerful for modules. A module can provide an abstract endpoint that defines an interface, and users of the module can extend it to expose the functionality on their server:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.strong,{children:["In a module (e.g., ",(0,s.jsx)(n.code,{children:"serverpod_auth"}),"):"]})}),"\n",(0,s.jsx)(n.p,{children:"Declare an abstract endpoint with common methods on the server:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"abstract class AuthSessionEndpoint extends Endpoint {\n  Future<bool> isAuthenticated(Session session) async {\n    return await session.isUserSignedIn;\n  }\n\n  Future<bool> logout(Session session, {required bool allSessions}) async {\n    // Implementation...\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Write client-side code that depends on the generated abstract type and uses its methods:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"class UserLoggedInWidget extends StatelessWidget {\n  final Client client;\n\n  UserLoggedInWidget({required this.client});\n\n  // Will throw if no concrete implementation of the endpoint exists.\n  EndpointAuthSession get sessionEndpoint =>\n      client.getEndpointOfType<EndpointAuthSession>();\n\n  @override\n  Widget build(BuildContext context) {\n    return FutureBuilder<bool>(\n      future: sessionEndpoint.isAuthenticated(),\n      builder: (context, snapshot) {\n        if (snapshot.connectionState == ConnectionState.waiting) {\n          return CircularProgressIndicator();\n        } else if (snapshot.hasError) {\n          return Text('Error: ${snapshot.error}');\n        } else if (snapshot.hasData && snapshot.data == true) {\n          return Text('User is logged in');\n        } else {\n          return Text('User is not logged in');\n        }\n      },\n    );\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"In the user application:"})}),"\n",(0,s.jsx)(n.p,{children:"The user will just have to extend the abstract endpoint to expose it on their server. Then, any client code that depends on the abstract endpoint will work seamlessly, regardless of the concrete class name or location."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"// Extend the module's abstract endpoint to expose it\nclass SessionEndpoint extends AuthSessionEndpoint {}\n"})}),"\n",(0,s.jsx)(n.p,{children:"This approach allows module developers to provide reusable endpoint logic while giving application developers full control over which endpoints are exposed on their server."})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>d,x:()=>r});var i=t(96540);const s={},o=i.createContext(s);function d(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:d(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);