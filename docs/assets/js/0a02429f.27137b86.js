"use strict";(globalThis.webpackChunkserverpod_docs=globalThis.webpackChunkserverpod_docs||[]).push([[867],{93555(e,n,o){o.r(n),o.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"concepts/database/row-locking","title":"Row locking","description":"Row-level locking allows you to lock specific rows in the database to prevent other transactions from modifying them while you work. This is essential for safely handling concurrent updates, such as processing payments, managing inventory, or any scenario where two transactions might conflict.","source":"@site/docs/06-concepts/06-database/13-row-locking.md","sourceDirName":"06-concepts/06-database","slug":"/concepts/database/row-locking","permalink":"/next/concepts/database/row-locking","draft":false,"unlisted":false,"editUrl":"https://github.com/serverpod/serverpod_docs/tree/main/docs/06-concepts/06-database/13-row-locking.md","tags":[],"version":"current","sidebarPosition":13,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Runtime parameters","permalink":"/next/concepts/database/runtime-parameters"},"next":{"title":"Configurations","permalink":"/next/concepts/configuration"}}');var s=o(74848),a=o(28453);const r={},i="Row locking",c={},d=[{value:"Locking rows with a read",id:"locking-rows-with-a-read",level:2},{value:"Locking rows without fetching data",id:"locking-rows-without-fetching-data",level:2},{value:"Lock modes",id:"lock-modes",level:2},{value:"Lock behavior",id:"lock-behavior",level:2}];function l(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"row-locking",children:"Row locking"})}),"\n",(0,s.jsx)(n.p,{children:"Row-level locking allows you to lock specific rows in the database to prevent other transactions from modifying them while you work. This is essential for safely handling concurrent updates, such as processing payments, managing inventory, or any scenario where two transactions might conflict."}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsxs)(n.p,{children:["All row locking operations require a ",(0,s.jsx)(n.a,{href:"transactions",children:"transaction"}),". An exception will be thrown if you attempt to acquire a lock without one."]})}),"\n",(0,s.jsx)(n.p,{children:"For the following examples we will use this model:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"class: Company\ntable: company\nfields:\n  name: String\n"})}),"\n",(0,s.jsx)(n.h2,{id:"locking-rows-with-a-read",children:"Locking rows with a read"}),"\n",(0,s.jsxs)(n.p,{children:["You can lock rows as part of a read operation by passing the ",(0,s.jsx)(n.code,{children:"lockMode"})," parameter to ",(0,s.jsx)(n.code,{children:"find"}),", ",(0,s.jsx)(n.code,{children:"findFirstRow"}),", or ",(0,s.jsx)(n.code,{children:"findById"}),". The locked rows are returned and held until the transaction completes."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"await session.db.transaction((transaction) async {\n  var companies = await Company.db.find(\n    session,\n    where: (t) => t.name.equals('Serverpod'),\n    lockMode: LockMode.forUpdate,\n    transaction: transaction,\n  );\n\n  // Rows are locked \u2014 safe to update without conflicts.\n  for (var company in companies) {\n    company.name = 'Updated name';\n    await Company.db.updateRow(session, company, transaction: transaction);\n  }\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["When a row is locked, other transactions that attempt to acquire a conflicting lock on the same rows will wait until the lock is released. Regular reads without a ",(0,s.jsx)(n.code,{children:"lockMode"})," are not affected and can still read the rows freely. If waiting is not desired, you can configure the ",(0,s.jsx)(n.a,{href:"#lock-behavior",children:"lock behavior"})," to either throw an exception immediately or skip locked rows."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"findFirstRow"})," and ",(0,s.jsx)(n.code,{children:"findById"})," methods also support locking. Here's an example using ",(0,s.jsx)(n.code,{children:"findById"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"await session.db.transaction((transaction) async {\n  var company = await Company.db.findById(\n    session,\n    companyId,\n    lockMode: LockMode.forUpdate,\n    transaction: transaction,\n  );\n\n  if (company != null) {\n    company.name = 'Updated name';\n    await Company.db.updateRow(session, company, transaction: transaction);\n  }\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"locking-rows-without-fetching-data",children:"Locking rows without fetching data"}),"\n",(0,s.jsxs)(n.p,{children:["If you only need to lock rows without reading their data, use the ",(0,s.jsx)(n.code,{children:"lockRows"})," method. This acquires locks with less overhead since no row data is transferred."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"await session.db.transaction((transaction) async {\n  await Company.db.lockRows(\n    session,\n    where: (t) => t.name.equals('Serverpod'),\n    lockMode: LockMode.forUpdate,\n    transaction: transaction,\n  );\n\n  // Rows are locked \u2014 perform updates using other methods.\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"lock-modes",children:"Lock modes"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"lockMode"})," parameter determines the type of lock acquired. Different lock modes allow varying levels of concurrent access."]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Lock Mode"}),(0,s.jsx)(n.th,{children:"Constant"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"For update"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"LockMode.forUpdate"})}),(0,s.jsx)(n.td,{children:"Exclusive lock that blocks all other locks. Use when you intend to update or delete the locked rows."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"For no key update"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"LockMode.forNoKeyUpdate"})}),(0,s.jsxs)(n.td,{children:["Exclusive lock that allows ",(0,s.jsx)(n.code,{children:"forKeyShare"})," locks. Use when updating non-key columns only."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"For share"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"LockMode.forShare"})}),(0,s.jsx)(n.td,{children:"Shared lock that blocks exclusive locks but allows other shared locks. Use when you need to ensure rows don't change while reading."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"For key share"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"LockMode.forKeyShare"})}),(0,s.jsx)(n.td,{children:"Weakest lock that only blocks changes to key columns."})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:["For a detailed explanation of how lock modes interact, see the ",(0,s.jsx)(n.a,{href:"https://www.postgresql.org/docs/current/explicit-locking.html#LOCKING-ROWS",children:"PostgreSQL documentation"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"lock-behavior",children:"Lock behavior"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"lockBehavior"})," parameter controls what happens when a requested row is already locked by another transaction. If not specified, the default behavior is to wait."]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Behavior"}),(0,s.jsx)(n.th,{children:"Constant"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Wait"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"LockBehavior.wait"})}),(0,s.jsx)(n.td,{children:"Wait until the lock becomes available. This is the default."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"No wait"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"LockBehavior.noWait"})}),(0,s.jsx)(n.td,{children:"Throw an exception immediately if any row is already locked."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Skip locked"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"LockBehavior.skipLocked"})}),(0,s.jsx)(n.td,{children:"Skip rows that are currently locked and return only the unlocked rows."})]})]})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"await session.db.transaction((transaction) async {\n  var companies = await Company.db.find(\n    session,\n    where: (t) => t.id < 100,\n    lockMode: LockMode.forUpdate,\n    lockBehavior: LockBehavior.skipLocked,\n    transaction: transaction,\n  );\n\n  // Only unlocked rows are returned.\n});\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"LockBehavior.skipLocked"})," is particularly useful for implementing job queues or work distribution, where multiple workers can each grab unlocked rows without waiting on each other."]})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},28453(e,n,o){o.d(n,{R:()=>r,x:()=>i});var t=o(96540);const s={},a=t.createContext(s);function r(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);