"use strict";(self.webpackChunkserverpod_docs=self.webpackChunkserverpod_docs||[]).push([[40712],{81835:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>r,default:()=>h,frontMatter:()=>d,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"concepts/working-with-endpoints","title":"Working with endpoints","description":"Endpoints are the connection points to the server from the client. With Serverpod, you add methods to your endpoint, and your client code will be generated to make the method call. For the code to be generated, you need to place the endpoint file anywhere under the lib directory of your server. Your endpoint should extend the Endpoint class. For methods to be generated, they need to return a typed Future, and its first argument should be a Session object. The Session object holds information about the call being made and provides access to the database.","source":"@site/versioned_docs/version-2.6.0/06-concepts/01-working-with-endpoints.md","sourceDirName":"06-concepts","slug":"/concepts/working-with-endpoints","permalink":"/concepts/working-with-endpoints","draft":false,"unlisted":false,"editUrl":"https://github.com/serverpod/serverpod_docs/tree/main/versioned_docs/version-2.6.0/06-concepts/01-working-with-endpoints.md","tags":[],"version":"2.6.0","sidebarPosition":1,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Authentication","permalink":"/tutorials/authentication"},"next":{"title":"Working with models","permalink":"/concepts/models"}}');var o=t(74848),s=t(28453);const d={},r="Working with endpoints",a={},c=[{value:"Passing parameters",id:"passing-parameters",level:2},{value:"Return types",id:"return-types",level:2},{value:"Ignore endpoint definition",id:"ignore-endpoint-definition",level:2},{value:"Ignore an entire <code>Endpoint</code> class",id:"ignore-an-entire-endpoint-class",level:3},{value:"Ignore individual <code>Endpoint</code> methods",id:"ignore-individual-endpoint-methods",level:3},{value:"Endpoint method inheritance",id:"endpoint-method-inheritance",level:2},{value:"Inheriting from an <code>Endpoint</code> class",id:"inheriting-from-an-endpoint-class",level:3},{value:"Inheriting from an <code>Endpoint</code> class marked <code>abstract</code>",id:"inheriting-from-an-endpoint-class-marked-abstract",level:3},{value:"Extending an <code>abstract</code> <code>Endpoint</code> class",id:"extending-an-abstract-endpoint-class",level:4},{value:"Inheriting from an <code>Endpoint</code> class annotated with <code>@ignoreEndpoint</code>",id:"inheriting-from-an-endpoint-class-annotated-with-ignoreendpoint",level:3},{value:"Overriding endpoint methods",id:"overriding-endpoint-methods",level:3},{value:"Hiding endpoint methods with <code>@ignoreEndpoint</code>",id:"hiding-endpoint-methods-with-ignoreendpoint",level:3},{value:"Unhiding endpoint methods annotated with <code>@ignoreEndpoint</code> in the super class",id:"unhiding-endpoint-methods-annotated-with-ignoreendpoint-in-the-super-class",level:3},{value:"Building base endpoints for behavior",id:"building-base-endpoints-for-behavior",level:3}];function l(e){const n={a:"a",admonition:"admonition",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"working-with-endpoints",children:"Working with endpoints"})}),"\n",(0,o.jsxs)(n.p,{children:["Endpoints are the connection points to the server from the client. With Serverpod, you add methods to your endpoint, and your client code will be generated to make the method call. For the code to be generated, you need to place the endpoint file anywhere under the ",(0,o.jsx)(n.code,{children:"lib"})," directory of your server. Your endpoint should extend the ",(0,o.jsx)(n.code,{children:"Endpoint"})," class. For methods to be generated, they need to return a typed ",(0,o.jsx)(n.code,{children:"Future"}),", and its first argument should be a ",(0,o.jsx)(n.code,{children:"Session"})," object. The ",(0,o.jsx)(n.code,{children:"Session"})," object holds information about the call being made and provides access to the database."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-dart",children:"import 'package:serverpod/serverpod.dart';\n\nclass ExampleEndpoint extends Endpoint {\n  Future<String> hello(Session session, String name) async {\n    return 'Hello $name';\n  }\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The above code will create an endpoint called ",(0,o.jsx)(n.code,{children:"example"})," (the Endpoint suffix will be removed) with the single ",(0,o.jsx)(n.code,{children:"hello"})," method. To generate the client-side code run ",(0,o.jsx)(n.code,{children:"serverpod generate"})," in the home directory of the server."]}),"\n",(0,o.jsx)(n.p,{children:"On the client side, you can now call the method by calling:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-dart",children:"var result = await client.example.hello('World');\n"})}),"\n",(0,o.jsx)(n.p,{children:"The client is initialized like this:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-dart",children:"// Sets up a singleton client object that can be used to talk to the server from\n// anywhere in our app. The client is generated from your server code.\n// The client is set up to connect to a Serverpod running on a local server on\n// the default port. You will need to modify this to connect to staging or\n// production servers.\nvar client = Client('http://$localhost:8080/')\n  ..connectivityMonitor = FlutterConnectivityMonitor();\n"})}),"\n",(0,o.jsxs)(n.p,{children:["If you run the app in an Android emulator, the ",(0,o.jsx)(n.code,{children:"localhost"})," parameter points to ",(0,o.jsx)(n.code,{children:"10.0.2.2"}),", rather than ",(0,o.jsx)(n.code,{children:"127.0.0.1"})," as this is the IP address of the host machine. To access the server from a different device on the same network (such as a physical phone) replace ",(0,o.jsx)(n.code,{children:"localhost"})," with the local ip address. You can find the local ip by running ",(0,o.jsx)(n.code,{children:"ifconfig"})," (Linux/MacOS) or ",(0,o.jsx)(n.code,{children:"ipconfig"})," (Windows)."]}),"\n",(0,o.jsxs)(n.p,{children:["Make sure to also update the ",(0,o.jsx)(n.code,{children:"publicHost"})," in the development config to make sure the server always serves the client with the correct path to assets etc."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:"# your_project_server/config/development.yaml\n\napiServer:\n  port: 8080\n  publicHost: localhost # Change this line\n  publicPort: 8080\n  publicScheme: http\n...\n"})}),"\n",(0,o.jsx)(n.admonition,{type:"info",children:(0,o.jsxs)(n.p,{children:["You can pass the ",(0,o.jsx)(n.code,{children:"--watch"})," flag to ",(0,o.jsx)(n.code,{children:"serverpod generate"})," to watch for changed files and generate code whenever your source files are updated. This is useful during the development of your server."]})}),"\n",(0,o.jsx)(n.h2,{id:"passing-parameters",children:"Passing parameters"}),"\n",(0,o.jsxs)(n.p,{children:["There are some limitations to how endpoint methods can be implemented. Parameters and return types can be of type ",(0,o.jsx)(n.code,{children:"bool"}),", ",(0,o.jsx)(n.code,{children:"int"}),", ",(0,o.jsx)(n.code,{children:"double"}),", ",(0,o.jsx)(n.code,{children:"String"}),", ",(0,o.jsx)(n.code,{children:"UuidValue"}),", ",(0,o.jsx)(n.code,{children:"Duration"}),", ",(0,o.jsx)(n.code,{children:"DateTime"}),", ",(0,o.jsx)(n.code,{children:"ByteData"}),", ",(0,o.jsx)(n.code,{children:"Uri"}),", ",(0,o.jsx)(n.code,{children:"BigInt"}),", or generated serializable objects (see next section). A typed ",(0,o.jsx)(n.code,{children:"Future"})," should always be returned. Null safety is supported. When passing a ",(0,o.jsx)(n.code,{children:"DateTime"})," it is always converted to UTC."]}),"\n",(0,o.jsxs)(n.p,{children:["You can also pass ",(0,o.jsx)(n.code,{children:"List"}),", ",(0,o.jsx)(n.code,{children:"Map"}),", ",(0,o.jsx)(n.code,{children:"Record"})," and ",(0,o.jsx)(n.code,{children:"Set"})," as parameters, but they need to be strictly typed with one of the types mentioned above."]}),"\n",(0,o.jsxs)(n.admonition,{type:"warning",children:[(0,o.jsxs)(n.p,{children:["While it's possible to pass binary data through a method call and ",(0,o.jsx)(n.code,{children:"ByteData"}),", it is not the most efficient way to transfer large files. See our ",(0,o.jsx)(n.a,{href:"file-uploads",children:"file upload"})," interface. The size of a call is by default limited to 512 kB. It's possible to change by adding the ",(0,o.jsx)(n.code,{children:"maxRequestSize"})," to your config files. E.g., this will double the request size to 1 MB:"]}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:"maxRequestSize: 1048576\n"})})]}),"\n",(0,o.jsx)(n.h2,{id:"return-types",children:"Return types"}),"\n",(0,o.jsx)(n.p,{children:"The return type must be a typed Future. Supported return types are the same as for parameters."}),"\n",(0,o.jsx)(n.h2,{id:"ignore-endpoint-definition",children:"Ignore endpoint definition"}),"\n",(0,o.jsxs)(n.h3,{id:"ignore-an-entire-endpoint-class",children:["Ignore an entire ",(0,o.jsx)(n.code,{children:"Endpoint"})," class"]}),"\n",(0,o.jsxs)(n.p,{children:["If you want the code generator to ignore an endpoint definition, you can annotate either the entire class or individual methods with ",(0,o.jsx)(n.code,{children:"@ignoreEndpoint"}),".  This can be useful if you want to keep the definition in your codebase without generating server or client bindings for it."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-dart",children:"import 'package:serverpod/serverpod.dart';\n\n@ignoreEndpoint\nclass ExampleEndpoint extends Endpoint {\n  Future<String> hello(Session session, String name) async {\n    return 'Hello $name';\n  }\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"The above code will not generate any server or client bindings for the example endpoint."}),"\n",(0,o.jsxs)(n.h3,{id:"ignore-individual-endpoint-methods",children:["Ignore individual ",(0,o.jsx)(n.code,{children:"Endpoint"})," methods"]}),"\n",(0,o.jsxs)(n.p,{children:["Alternatively, you can disable single methods by annotation them with ",(0,o.jsx)(n.code,{children:"@ignoreEndpoint"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-dart",children:"import 'package:serverpod/serverpod.dart';\n\nclass ExampleEndpoint extends Endpoint {\n  Future<String> hello(Session session, String name) async {\n    return 'Hello $name';\n  }\n\n  @ignoreEndpoint\n  Future<String> goodbye(Session session, String name) async {\n    return 'Bye $name';\n  }\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["In this case the ",(0,o.jsx)(n.code,{children:"ExampleEndpoint"})," will only expose the ",(0,o.jsx)(n.code,{children:"hello"})," method, whereas the ",(0,o.jsx)(n.code,{children:"goodbye"})," method will not be accessible externally."]}),"\n",(0,o.jsx)(n.h2,{id:"endpoint-method-inheritance",children:"Endpoint method inheritance"}),"\n",(0,o.jsxs)(n.p,{children:["Endpoints can be based on other endpoints using inheritance, like ",(0,o.jsx)(n.code,{children:"class ChildEndpoint extends ParentEndpoint"}),". If the parent endpoint was marked as ",(0,o.jsx)(n.code,{children:"abstract"})," or ",(0,o.jsx)(n.code,{children:"@ignoreEndpoint"}),", no client code is generated for it, but a client will be generated for your subclass \u2013 as long as it does not opt out again.",(0,o.jsx)(n.br,{}),"\n","Inheritance gives you the possibility to modify the behavior of ",(0,o.jsx)(n.code,{children:"Endpoint"})," classes defined in other Serverpod modules."]}),"\n",(0,o.jsxs)(n.p,{children:["Currently, there are the following possibilities to extend another ",(0,o.jsx)(n.code,{children:"Endpoint"})," class:"]}),"\n",(0,o.jsxs)(n.h3,{id:"inheriting-from-an-endpoint-class",children:["Inheriting from an ",(0,o.jsx)(n.code,{children:"Endpoint"})," class"]}),"\n",(0,o.jsxs)(n.p,{children:["Given an existing ",(0,o.jsx)(n.code,{children:"Endpoint"})," class, it is possible to extend or modify its behavior while retaining the already exposed methods."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-dart",children:"import 'package:serverpod/serverpod.dart';\n\nclass CalculatorEndpoint extends Endpoint {\n  Future<int> add(Session session, int a, int b) async {\n    return a + b;\n  }\n}\n\nclass MyCalculatorEndpoint extends CalculatorEndpoint {\n  Future<int> subtract(Session session, int a, int b) async {\n    return a - b;\n  }\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The generated client code will now be able to access both ",(0,o.jsx)(n.code,{children:"CalculatorEndpoint"})," and ",(0,o.jsx)(n.code,{children:"MyCalculatorEndpoint"}),".\nWhereas the ",(0,o.jsx)(n.code,{children:"CalculatorEndpoint"})," only exposes the original ",(0,o.jsx)(n.code,{children:"add"})," method, ",(0,o.jsx)(n.code,{children:"MyCalculatorEndpoint"})," now exposes both the inherited ",(0,o.jsx)(n.code,{children:"add"})," and its own ",(0,o.jsx)(n.code,{children:"subtract"})," methods."]}),"\n",(0,o.jsxs)(n.h3,{id:"inheriting-from-an-endpoint-class-marked-abstract",children:["Inheriting from an ",(0,o.jsx)(n.code,{children:"Endpoint"})," class marked ",(0,o.jsx)(n.code,{children:"abstract"})]}),"\n",(0,o.jsxs)(n.p,{children:["Endpoints marked as ",(0,o.jsx)(n.code,{children:"abstract"})," are not added to the server. But if they are subclassed, their methods will be exposed through the subclass."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-dart",children:"import 'package:serverpod/serverpod.dart';\n\nabstract class CalculatorEndpoint extends Endpoint {\n  Future<int> add(Session session, int a, int b) async {\n    return a + b;\n  }\n}\n\nclass MyCalculatorEndpoint extends CalculatorEndpoint {}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The generated client code will only be able to access ",(0,o.jsx)(n.code,{children:"MyCalculatorEndpoint"}),", as the abstract ",(0,o.jsx)(n.code,{children:"CalculatorEndpoint"})," is not exposed on the server.\n",(0,o.jsx)(n.code,{children:"MyCalculatorEndpoint"})," exposes the ",(0,o.jsx)(n.code,{children:"add"})," method it inherited from ",(0,o.jsx)(n.code,{children:"CalculatorEndpoint"}),"."]}),"\n",(0,o.jsxs)(n.h4,{id:"extending-an-abstract-endpoint-class",children:["Extending an ",(0,o.jsx)(n.code,{children:"abstract"})," ",(0,o.jsx)(n.code,{children:"Endpoint"})," class"]}),"\n",(0,o.jsxs)(n.p,{children:["In the above example, the ",(0,o.jsx)(n.code,{children:"MyCalculatorEndpoint"})," only exposed the inherited ",(0,o.jsx)(n.code,{children:"add"})," method. It can be further extended with custom methods like this:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-dart",children:"import 'package:serverpod/serverpod.dart';\n\nclass MyCalculatorEndpoint extends CalculatorEndpoint {\n  Future<int> subtract(Session session, int a, int b) async {\n    return a - b;\n  }\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["In this case, it will expose both an ",(0,o.jsx)(n.code,{children:"add"})," and a ",(0,o.jsx)(n.code,{children:"subtract"})," method."]}),"\n",(0,o.jsxs)(n.h3,{id:"inheriting-from-an-endpoint-class-annotated-with-ignoreendpoint",children:["Inheriting from an ",(0,o.jsx)(n.code,{children:"Endpoint"})," class annotated with ",(0,o.jsx)(n.code,{children:"@ignoreEndpoint"})]}),"\n",(0,o.jsxs)(n.p,{children:["Suppose you had an ",(0,o.jsx)(n.code,{children:"Endpoint"})," class marked with ",(0,o.jsx)(n.code,{children:"@ignoreEndpoint"})," and a subclass that extends it:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-dart",children:"import 'package:serverpod/serverpod.dart';\n\n@ignoreEndpoint\nclass CalculatorEndpoint extends Endpoint {\n  Future<int> add(Session session, int a, int b) async {\n    return a + b;\n  }\n}\n\nclass MyCalculatorEndpoint extends CalculatorEndpoint {}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Since ",(0,o.jsx)(n.code,{children:"CalculatorEndpoint"})," is marked as ",(0,o.jsx)(n.code,{children:"@ignoreEndpoint"})," it will not be exposed on the server. Only ",(0,o.jsx)(n.code,{children:"MyCalculatorEndpoint"})," will be accessible from the client, which provides the inherited ",(0,o.jsx)(n.code,{children:"add"})," methods from its parent class."]}),"\n",(0,o.jsx)(n.h3,{id:"overriding-endpoint-methods",children:"Overriding endpoint methods"}),"\n",(0,o.jsx)(n.p,{children:"It is possible to override methods of the superclass. This can be useful when you want to modify the behavior of specific methods but preserve the rest."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-dart",children:"import 'package:serverpod/serverpod.dart';\n\nabstract class GreeterBaseEndpoint extends Endpoint {\n  Future<String> greet(Session session, String name) async {\n    return 'Hello $name';\n  }\n}\n\nclass ExcitedGreeterEndpoint extends GreeterBaseEndpoint {\n  @override\n  Future<String> greet(Session session, String name) async {\n    return '${super.hello(session, name)}!!!';\n  }\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Since ",(0,o.jsx)(n.code,{children:"GreeterBaseEndpoint"})," is ",(0,o.jsx)(n.code,{children:"abstract"}),", it will not be exposed on the server. The ",(0,o.jsx)(n.code,{children:"ExcitedGreeterEndpoint"})," will expose a single ",(0,o.jsx)(n.code,{children:"greet"})," method, and its implementation will augment the superclass's one by adding ",(0,o.jsx)(n.code,{children:"!!!"})," to that result."]}),"\n",(0,o.jsxs)(n.p,{children:["This way, you can modify the behavior of endpoint methods while still sharing the implementation through calls to ",(0,o.jsx)(n.code,{children:"super"}),". Be aware that the method signature has to be compatible with the base class per Dart's rules, meaning you can add optional parameters, but can not add required parameters or change the return type."]}),"\n",(0,o.jsxs)(n.h3,{id:"hiding-endpoint-methods-with-ignoreendpoint",children:["Hiding endpoint methods with ",(0,o.jsx)(n.code,{children:"@ignoreEndpoint"})]}),"\n",(0,o.jsxs)(n.p,{children:["In case you want to hide methods from an endpoint use ",(0,o.jsx)(n.code,{children:"@ignoreEndpoint"})," in the child class like so:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-dart",children:"import 'package:serverpod/serverpod.dart';\n\nabstract class CalculatorEndpoint extends Endpoint {\n  Future<int> add(Session session, int a, int b) async {\n    return a + b;\n  }\n\n  Future<int> subtract(Session session, int a, int b) async {\n    return a - b;\n  }\n}\n\nclass AdderEndpoint extends CalculatorEndpoint {\n  @ignoreEndpoint\n  Future<int> subtract(Session session, int a, int b) async {\n    throw UnimplementedError();\n  }\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Since ",(0,o.jsx)(n.code,{children:"CalculatorEndpoint"})," is ",(0,o.jsx)(n.code,{children:"abstract"}),", it will not be exposed on the server. ",(0,o.jsx)(n.code,{children:"AdderEndpoint"})," inherits all methods from its parent class, but since it opts to hide ",(0,o.jsx)(n.code,{children:"subtract"})," by annotating it with ",(0,o.jsx)(n.code,{children:"@ignoreEndpoint"})," only the ",(0,o.jsx)(n.code,{children:"add"})," method will be exposed.\nDon't worry about the exception in the ",(0,o.jsx)(n.code,{children:"subtract"})," implementation. That is only added to satisfy the Dart compiler \u2013\xa0in practice, nothing will ever call this method on ",(0,o.jsx)(n.code,{children:"AdderEndpoint"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["Hiding endpoints from a super class is only appropriate in case the parent ",(0,o.jsx)(n.code,{children:"class"})," is ",(0,o.jsx)(n.code,{children:"abstract"})," or annotated with ",(0,o.jsx)(n.code,{children:"@ignoreEndpoint"}),". Otherwise, the method that should be hidden on the child would still be accessible via the parent class."]}),"\n",(0,o.jsxs)(n.h3,{id:"unhiding-endpoint-methods-annotated-with-ignoreendpoint-in-the-super-class",children:["Unhiding endpoint methods annotated with ",(0,o.jsx)(n.code,{children:"@ignoreEndpoint"})," in the super class"]}),"\n",(0,o.jsxs)(n.p,{children:["The reverse of the previous example would be a base endpoint that has a method marked with ",(0,o.jsx)(n.code,{children:"@ignoreEndpoint"}),", which you now want to expose on the subclass."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-dart",children:"import 'package:serverpod/serverpod.dart';\n\nabstract class CalculatorEndpoint extends Endpoint {\n  Future<int> add(Session session, int a, int b) async {\n    return a + b;\n  }\n\n  // Ignored, as this expensive computation should not be exposed by default\n  @ignoreEndpoint\n  Future<BigInt> addBig(Session session, BigInt a, BigInt b) async {\n    return a + b;\n  }\n}\n\nclass MyCalculatorEndpoint extends CalculatorEndpoint {\n  @override\n  Future<BigInt> addBig(Session session, BigInt a, BigInt b) async {\n    return super.addBig(session, a, b);\n  }\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Since ",(0,o.jsx)(n.code,{children:"CalculatorEndpoint"})," is ",(0,o.jsx)(n.code,{children:"abstract"}),", it will not be exposed on the server. ",(0,o.jsx)(n.code,{children:"MyCalculatorEndpoint"})," will expose both the ",(0,o.jsx)(n.code,{children:"add"})," and ",(0,o.jsx)(n.code,{children:"addBig"})," methods, since ",(0,o.jsx)(n.code,{children:"addBig"})," was overridden and thus lost the ",(0,o.jsx)(n.code,{children:"@ignoreEndpoint"})," annotation."]}),"\n",(0,o.jsx)(n.h3,{id:"building-base-endpoints-for-behavior",children:"Building base endpoints for behavior"}),"\n",(0,o.jsxs)(n.p,{children:["Endpoint subclassing is not just useful to inherit (or hide) methods, it can also be used to pre-configure any other property of the ",(0,o.jsx)(n.code,{children:"Endpoint"})," class."]}),"\n",(0,o.jsx)(n.p,{children:"For example, you could define a base class that requires callers to be logged in:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-dart",children:"abstract class LoggedInEndpoint extends Endpoint {\n  @override\n  bool get requireLogin => true;\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["And now every endpoint that extends ",(0,o.jsx)(n.code,{children:"LoggedInEndpoint"})," will check that the user is logged in."]}),"\n",(0,o.jsx)(n.p,{children:"Similarly, you could wrap up a specific set of required scopes in a base endpoint, which you can then easily use for the app's endpoints instead of repeating the scopes in each:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-dart",children:"abstract class AdminEndpoint extends Endpoint {\n  @override\n  Set<Scope> get requiredScopes => {Scope.admin};\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Again, just have your custom endpoint extend ",(0,o.jsx)(n.code,{children:"AdminEndpoint"})," and you can be sure that the user has the appropriate permissions."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>d,x:()=>r});var i=t(96540);const o={},s=i.createContext(o);function d(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:d(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);