"use strict";(globalThis.webpackChunkserverpod_docs=globalThis.webpackChunkserverpod_docs||[]).push([[12384],{77073(e,n,s){s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"concepts/authentication/token-managers/server-side-sessions-token-manager","title":"Server-side Sessions Token Manager","description":"The ServerSideSessionsTokenManager uses session-based tokens stored in the database. This token manager provides:","source":"@site/docs/06-concepts/11-authentication/05-token-managers/03-server-side-sessions-token-manager.md","sourceDirName":"06-concepts/11-authentication/05-token-managers","slug":"/concepts/authentication/token-managers/server-side-sessions-token-manager","permalink":"/next/concepts/authentication/token-managers/server-side-sessions-token-manager","draft":false,"unlisted":false,"editUrl":"https://github.com/serverpod/serverpod_docs/tree/main/docs/06-concepts/11-authentication/05-token-managers/03-server-side-sessions-token-manager.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"JWT Token Manager","permalink":"/next/concepts/authentication/token-managers/jwt-token-manager"},"next":{"title":"UI Components","permalink":"/next/concepts/authentication/ui-components"}}');var t=s(74848),o=s(28453);const a={},r="Server-side Sessions Token Manager",d={},c=[{value:"Server-side configuration",id:"server-side-configuration",level:2},{value:"Basic configuration options",id:"basic-configuration-options",level:3},{value:"Extra configuration options",id:"extra-configuration-options",level:3},{value:"Attaching custom metadata to sessions",id:"attaching-custom-metadata-to-sessions",level:3},{value:"Attaching metadata when issuing tokens from an endpoint",id:"attaching-metadata-when-issuing-tokens-from-an-endpoint",level:4},{value:"Client-side configuration",id:"client-side-configuration",level:2}];function l(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"server-side-sessions-token-manager",children:"Server-side Sessions Token Manager"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"ServerSideSessionsTokenManager"})," uses session-based tokens stored in the database. This token manager provides:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Stateful authentication (database queries for validation)."}),"\n",(0,t.jsx)(n.li,{children:"Immediate session revocation."}),"\n",(0,t.jsx)(n.li,{children:"Immediate scopes update on existing sessions."}),"\n",(0,t.jsx)(n.li,{children:"Support for session expiration and inactivity timeouts."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"server-side-configuration",children:"Server-side configuration"}),"\n",(0,t.jsxs)(n.p,{children:["This token manager is created by passing a ",(0,t.jsx)(n.code,{children:"ServerSideSessionsConfig"})," object to the ",(0,t.jsx)(n.code,{children:"pod.initializeAuthServices()"})," as a ",(0,t.jsx)(n.code,{children:"tokenManagerBuilder"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"pod.initializeAuthServices(\n  tokenManagerBuilders: [\n    ServerSideSessionsConfig(\n      // The pepper used to hash the session key.\n      sessionKeyHashPepper: pod.getPassword('serverSideSessionKeyHashPepper')!,\n    ),\n  ],\n);\n"})}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsxs)(n.p,{children:["You can use the ",(0,t.jsx)(n.code,{children:"ServerSideSessionsConfigFromPasswords"})," constructor in replacement of the ",(0,t.jsx)(n.code,{children:"ServerSideSessionsConfig"})," above to automatically load the credentials from the ",(0,t.jsx)(n.code,{children:"config/passwords.yaml"})," file or environment variables. It will expect the ",(0,t.jsx)(n.code,{children:"serverSideSessionKeyHashPepper"})," key on the file or the ",(0,t.jsx)(n.code,{children:"SERVERPOD_PASSWORD_serverSideSessionKeyHashPepper"})," environment variable."]})}),"\n",(0,t.jsx)(n.h3,{id:"basic-configuration-options",children:"Basic configuration options"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"sessionKeyHashPepper"}),": Required. A secret pepper used for hashing session keys. Must be at least 10 characters long, but ",(0,t.jsx)(n.a,{href:"https://www.ietf.org/archive/id/draft-ietf-kitten-password-storage-04.html#name-storage-2",children:"the recommended length is 32 bytes"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"extra-configuration-options",children:"Extra configuration options"}),"\n",(0,t.jsxs)(n.p,{children:["Below is an example of a non-exhaustive list of some of the most common configuration options for the ",(0,t.jsx)(n.code,{children:"ServerSideSessionsTokenManager"}),". For more details on all options, check the ",(0,t.jsx)(n.code,{children:"ServerSideSessionsConfig"})," in-code documentation."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"final serverSideSessionsConfig = ServerSideSessionsConfigFromPasswords(\n  // Optional: Fallback peppers for pepper rotation\n  // This is useful for allowing old sessions to be validated after a rotation.\n  fallbackSessionKeyHashPeppers: [\n    pod.getPassword('oldSessionKeyHashPepper')!,\n  ],\n  // Optional: Set default session lifetime (default is to never expire)\n  defaultSessionLifetime: Duration(days: 30),\n  // Optional: Set inactivity timeout (default is to never timeout)\n  defaultSessionInactivityTimeout: Duration(days: 7),\n  // Optional: Configure session key properties\n  sessionKeySecretLength: 32,\n  sessionKeyHashSaltLength: 16,\n  // Check the [ServerSideSessionsConfig] documentation for more options.\n);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"attaching-custom-metadata-to-sessions",children:"Attaching custom metadata to sessions"}),"\n",(0,t.jsxs)(n.p,{children:["You can attach custom metadata to each server-side session by providing an ",(0,t.jsx)(n.code,{children:"onSessionCreated"}),' callback. This is useful for storing device information, IP address, user agent, or any other data you need to query or display later (for example, in a "sessions" or "devices" list). The callback runs when a session is created, within the same transaction as the session insert.']}),"\n",(0,t.jsxs)(n.p,{children:["Define a server-only table that relates to ",(0,t.jsx)(n.code,{children:"ServerSideSession"})," and store your metadata there. Example schema:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"class: SessionMetadata\nserverOnly: true\ntable: session_metadata\nfields:\n  ### The [ServerSideSession] this metadata belongs to\n  serverSideSession: module:serverpod_auth_core:ServerSideSession?, relation(onDelete=Cascade)\n\n  ### The name of the token\n  name: String?\n\n  ### Device information for the session\n  deviceName: String?\n\n  ### IP address from which the session was created\n  ipAddress: String?\n\n  ### User agent string\n  userAgent: String?\n\nindexes:\n  server_side_session_id_unique_idx:\n    fields: serverSideSessionId\n    unique: true\n"})}),"\n",(0,t.jsx)(n.p,{children:"Then configure the callback in your server-side sessions config:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"ServerSideSessionsConfigFromPasswords(\n  onSessionCreated:\n      (\n        final session, {\n        required final authUserId,\n        required final serverSideSessionId,\n        required final transaction,\n      }) async {\n        await SessionMetadata.db.insertRow(\n          session,\n          SessionMetadata(\n            serverSideSessionId: serverSideSessionId,\n            name: 'general-session',\n            ipAddress: session.request?.connectionInfo.remote.address.toString(),\n            userAgent: session.request?.headers.userAgent,\n          ),\n          transaction: transaction,\n        );\n      },\n),\n"})}),"\n",(0,t.jsxs)(n.p,{children:["To revoke tokens based on your custom metadata, query the metadata table for the session IDs you want to revoke and call ",(0,t.jsx)(n.code,{children:"revokeToken"})," for each:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"final tokenMetadata = await SessionMetadata.db.find(\n  session,\n  where: (final row) => row.deviceName.equals('Old Device'),\n);\n\nfor (final row in tokenMetadata) {\n  await AuthServices.instance.tokenManager.revokeToken(\n    session,\n    tokenId: row.serverSideSessionId.toString(),\n  );\n}\n"})}),"\n",(0,t.jsx)(n.h4,{id:"attaching-metadata-when-issuing-tokens-from-an-endpoint",children:"Attaching metadata when issuing tokens from an endpoint"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"onSessionCreated"})," callback is global and runs for every new session (including those created by identity providers). When you create a token from an endpoint\u2014for example, a personal access token (PAT) or CLI token\u2014you often have endpoint-specific parameters (e.g. a token name or label) that the callback cannot see. In that case, issue the token with ",(0,t.jsx)(n.code,{children:"AuthServices.instance.tokenManager.issueToken"}),", then use the returned ",(0,t.jsx)(n.code,{children:"AuthSuccess.serverSideSessionId"})," to insert your metadata with the endpoint's parameters:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"final authSuccess = await AuthServices.instance.tokenManager.issueToken(\n  session,\n  authUserId: userId,\n  method: 'pat',\n  scopes: {Scope.admin},\n);\n\nawait SessionMetadata.db.insertRow(\n  session,\n  SessionMetadata(\n    serverSideSessionId: authSuccess.serverSideSessionId,\n    name: tokenName, // from your endpoint parameter\n    deviceName: deviceName, // from your endpoint parameter\n    ipAddress: session.request?.connectionInfo.remote.address.toString(),\n    userAgent: session.request?.headers.userAgent,\n  ),\n);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["See ",(0,t.jsx)(n.a,{href:"./managing-tokens#issuing-tokens",children:"Issuing Tokens"})," in Managing tokens for more context."]}),"\n",(0,t.jsx)(n.h2,{id:"client-side-configuration",children:"Client-side configuration"}),"\n",(0,t.jsxs)(n.p,{children:["When using the ",(0,t.jsx)(n.code,{children:"ServerSideSessionsTokenManager"})," in the server, no extra configuration is needed on the client. It will automatically include the session token in requests to the server. In case the session expires or is revoked, the client will automatically sign the user out and redirect to the login page."]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},28453(e,n,s){s.d(n,{R:()=>a,x:()=>r});var i=s(96540);const t={},o=i.createContext(t);function a(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);