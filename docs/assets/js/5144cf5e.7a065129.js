"use strict";(globalThis.webpackChunkserverpod_docs=globalThis.webpackChunkserverpod_docs||[]).push([[58800],{17059(e,n,t){t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>l,frontMatter:()=>a,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"concepts/authentication/basics","title":"The basics","description":"Serverpod automatically checks if the user is logged in and if the user has the right privileges to access each endpoint. When using the Serverpod Authentication modules, you will not have to worry about keeping track of tokens, refreshing them or even including them in requests as this all happens automatically under the hood.","source":"@site/docs/06-concepts/11-authentication/02-basics.md","sourceDirName":"06-concepts/11-authentication","slug":"/concepts/authentication/basics","permalink":"/next/concepts/authentication/basics","draft":false,"unlisted":false,"editUrl":"https://github.com/serverpod/serverpod_docs/tree/main/docs/06-concepts/11-authentication/02-basics.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Setup","permalink":"/next/concepts/authentication/setup"},"next":{"title":"Working with users","permalink":"/next/concepts/authentication/working-with-users"}}');var s=t(74848),o=t(28453);const a={},r="The basics",c={},d=[{value:"Requiring authentication on endpoints",id:"requiring-authentication-on-endpoints",level:2},{value:"Explicitly allowing unauthenticated access",id:"explicitly-allowing-unauthenticated-access",level:2},{value:"Authorization on endpoints",id:"authorization-on-endpoints",level:2},{value:"Managing scopes",id:"managing-scopes",level:3},{value:"Custom scopes",id:"custom-scopes",level:3},{value:"Client-side authentication",id:"client-side-authentication",level:2},{value:"Check authentication state",id:"check-authentication-state",level:3},{value:"Access current authentication info",id:"access-current-authentication-info",level:3},{value:"Register authentication",id:"register-authentication",level:3},{value:"Monitor authentication changes",id:"monitor-authentication-changes",level:3},{value:"Signing out users",id:"signing-out-users",level:3},{value:"Sign out current device",id:"sign-out-current-device",level:4},{value:"Sign out all devices",id:"sign-out-all-devices",level:4}];function h(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"the-basics",children:"The basics"})}),"\n",(0,s.jsx)(n.p,{children:"Serverpod automatically checks if the user is logged in and if the user has the right privileges to access each endpoint. When using the Serverpod Authentication modules, you will not have to worry about keeping track of tokens, refreshing them or even including them in requests as this all happens automatically under the hood."}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"Session"})," object provides information about the current user. A unique ",(0,s.jsx)(n.code,{children:"userIdentifier"})," identifies a user as a ",(0,s.jsx)(n.code,{children:"UuidValue"}),". You should use this id whenever you are referring to a user. Access the id of a signed-in user through the ",(0,s.jsx)(n.code,{children:"authenticated"})," asynchronous getter of the ",(0,s.jsx)(n.code,{children:"Session"})," object."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"Future<void> myMethod(Session session) async {\n  final authenticationInfo = session.authenticated;\n  final userIdentifier = authenticationInfo?.userIdentifier;\n  ...\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"You can also use the Session object to check if a user is authenticated:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"Future<void> myMethod(Session session) async {\n  var isSignedIn = session.isUserSignedIn;\n  ...\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"requiring-authentication-on-endpoints",children:"Requiring authentication on endpoints"}),"\n",(0,s.jsxs)(n.p,{children:["It is common to want to restrict access to an endpoint to users that have signed in. You can do this by overriding the ",(0,s.jsx)(n.code,{children:"requireLogin"})," property of the ",(0,s.jsx)(n.code,{children:"Endpoint"})," class."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"class MyEndpoint extends Endpoint {\n  @override\n  bool get requireLogin => true;\n\n  Future<void> myMethod(Session session) async {\n    ...\n  }\n  ...\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"explicitly-allowing-unauthenticated-access",children:"Explicitly allowing unauthenticated access"}),"\n",(0,s.jsxs)(n.p,{children:["In some cases, you may want to explicitly allow certain endpoints or methods to be accessed without authentication. Serverpod provides the ",(0,s.jsx)(n.code,{children:"@unauthenticatedClientCall"})," annotation for this purpose."]}),"\n",(0,s.jsxs)(n.p,{children:["When an endpoint or method is annotated with ",(0,s.jsx)(n.code,{children:"@unauthenticatedClientCall"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"No authentication will be added to the header on the client when calling it."}),"\n",(0,s.jsx)(n.li,{children:"The server will receive calls as if there is no user signed in."}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["Under the hood, the ",(0,s.jsx)(n.code,{children:"@unauthenticatedClientCall"})," annotation makes the client omit authentication headers for calls to the annotated endpoint or method. On the server side, it ensures that the session is treated as unauthenticated for those calls, regardless of any existing authentication state."]})}),"\n",(0,s.jsx)(n.p,{children:"You can use this annotation in two ways:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"On the entire endpoint class to make all methods unauthenticated:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"@unauthenticatedClientCall\nclass UnauthenticatedEndpoint extends Endpoint {\n  Future<bool> someMethod(Session session) async {\n    return session.isUserSignedIn; // Will always return false\n  }\n\n  Stream<bool> someStream(Session session) async* {\n    yield session.isUserSignedIn; // Will always return false\n  }\n}\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"On specific methods to make only those methods unauthenticated:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"class PartiallyUnauthenticatedEndpoint extends Endpoint {\n  @unauthenticatedClientCall\n  Future<bool> publicMethod(Session session) async {\n    return session.isUserSignedIn; // Will always return false\n  }\n\n  Future<bool> authenticatedMethod(Session session) async {\n    return session.isUserSignedIn;\n  }\n}\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This is particularly useful for endpoints that must not receive authentication, such as JWT refresh endpoints."}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsxs)(n.p,{children:["Using ",(0,s.jsx)(n.code,{children:"@unauthenticatedClientCall"})," on an endpoint or method that also has ",(0,s.jsx)(n.code,{children:"requireLogin"})," set to true will lead to a conflict. Since the client will suppress sending authentication information, but the server will expect it, calls to such endpoints or methods will always fail with an authentication error."]})}),"\n",(0,s.jsx)(n.h2,{id:"authorization-on-endpoints",children:"Authorization on endpoints"}),"\n",(0,s.jsxs)(n.p,{children:["Serverpod also supports scopes for restricting access. One or more scopes can be associated with a user. For instance, this can be used to give admin access to a specific user. To restrict access for an endpoint, override the ",(0,s.jsx)(n.code,{children:"requiredScopes"})," property. Note that setting ",(0,s.jsx)(n.code,{children:"requiredScopes"})," implicitly sets ",(0,s.jsx)(n.code,{children:"requireLogin"})," to true."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"class MyEndpoint extends Endpoint {\n  @override\n  bool get requireLogin => true;\n\n  @override\n  Set<Scope> get requiredScopes => {Scope.admin};\n\n  Future<void> myMethod(Session session) async {\n    ...\n  }\n  ...\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"managing-scopes",children:"Managing scopes"}),"\n",(0,s.jsxs)(n.p,{children:["New users are created without any scopes. To update a user's scopes, use the ",(0,s.jsx)(n.code,{children:"update"})," method from ",(0,s.jsx)(n.code,{children:"AuthServices.instance.authUsers"}),". This method replaces all previously stored scopes."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"import 'package:serverpod_auth_idp_server/core.dart';\n\nawait AuthServices.instance.authUsers.update(\n  session,\n  authUserId: authUserId,\n  scopes: {Scope.admin},\n);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"custom-scopes",children:"Custom scopes"}),"\n",(0,s.jsx)(n.p,{children:"You may need more granular access control for specific endpoints. To create custom scopes, extend the Scope class, as shown below:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"class CustomScope extends Scope {\n  const CustomScope(String name) : super(name);\n\n  static const userRead = CustomScope('userRead');\n  static const userWrite = CustomScope('userWrite');\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Then use the custom scopes like this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"class MyEndpoint extends Endpoint {\n  @override\n  bool get requireLogin => true;\n\n  @override\n  Set<Scope> get requiredScopes => {CustomScope.userRead, CustomScope.userWrite};\n\n  Future<void> myMethod(Session session) async {\n    ...\n  }\n  ...\n}\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"caution",children:(0,s.jsx)(n.p,{children:"Keep in mind that a scope is merely an arbitrary string and can be written in any format you prefer. However, it's crucial to use unique strings for each scope, as duplicated scope strings may lead to unintentional data exposure."})}),"\n",(0,s.jsx)(n.h2,{id:"client-side-authentication",children:"Client-side authentication"}),"\n",(0,s.jsxs)(n.p,{children:["On the client side, authentication state is managed through the ",(0,s.jsx)(n.code,{children:"FlutterAuthSessionManager"}),", which is accessible via ",(0,s.jsx)(n.code,{children:"client.auth"}),"."]}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["If you are building a pure Dart application using Serverpod, you can use the ",(0,s.jsx)(n.code,{children:"ClientAuthSessionManager"})," declared in the ",(0,s.jsx)(n.code,{children:"serverpod_auth_core_client"})," package instead of the ",(0,s.jsx)(n.code,{children:"FlutterAuthSessionManager"}),". It has the same functionality, with the exception of a ",(0,s.jsx)(n.code,{children:"authInfoListenable"})," getter that is tied to the Flutter framework."]})}),"\n",(0,s.jsx)(n.h3,{id:"check-authentication-state",children:"Check authentication state"}),"\n",(0,s.jsx)(n.p,{children:"To check if the user is signed in:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"bool isSignedIn = client.auth.isAuthenticated;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Returns ",(0,s.jsx)(n.code,{children:"true"})," if the user is signed in, or ",(0,s.jsx)(n.code,{children:"false"})," otherwise."]}),"\n",(0,s.jsx)(n.h3,{id:"access-current-authentication-info",children:"Access current authentication info"}),"\n",(0,s.jsx)(n.p,{children:"To retrieve information about the current authentication:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"AuthSuccess? authInfo = client.auth.authInfo;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Returns an ",(0,s.jsx)(n.code,{children:"AuthSuccess"})," object if the user is currently signed in, or ",(0,s.jsx)(n.code,{children:"null"})," if the user is not."]}),"\n",(0,s.jsx)(n.h3,{id:"register-authentication",children:"Register authentication"}),"\n",(0,s.jsx)(n.p,{children:"To register a signed in user, call:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"await client.auth.updateSignedInUser(authInfo);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This will persist the authentication information and refresh any open streaming connection. This is the method used by identity providers to register a signed in user. For more details on providers, see ",(0,s.jsx)(n.a,{href:"providers/custom-providers/overview",children:"Custom Providers"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"monitor-authentication-changes",children:"Monitor authentication changes"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"FlutterAuthSessionManager"})," exposes an ",(0,s.jsx)(n.code,{children:"authInfoListenable"})," that is a ",(0,s.jsx)(n.code,{children:"ValueListenable<AuthSuccess?>"})," to be used for listening to changes. This is useful for updating the UI when the authentication state changes:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"@override\nvoid initState() {\n  super.initState();\n\n  // Listen to authentication state changes.\n  client.auth.authInfoListenable.addListener(_onAuthStateChanged);\n}\n\n// Don't forget to remove the listener when the widget is disposed.\n@override\nvoid dispose() {\n  client.auth.authInfoListenable.removeListener(_onAuthStateChanged);\n  super.dispose();\n}\n\nvoid _onAuthStateChanged() {\n  setState(() {\n    // UI will rebuild when auth state changes.\n  });\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"The listener is triggered whenever the user's sign-in state changes.## User authentication"}),"\n",(0,s.jsx)(n.h3,{id:"signing-out-users",children:"Signing out users"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"FlutterAuthSessionManager"})," provides methods for handling user sign-outs, whether from a single device or all devices."]}),"\n",(0,s.jsxs)(n.admonition,{type:"info",children:[(0,s.jsxs)(n.p,{children:["The below methods use the ",(0,s.jsx)(n.code,{children:"StatusEndpoint"})," methods under the hood, which are also directly accessible on the client using the ",(0,s.jsx)(n.code,{children:"client.modules.auth.status"})," getter. In addition to these methods, Serverpod provides more comprehensive tools for managing user authentication and sign-out processes across multiple devices."]}),(0,s.jsxs)(n.p,{children:["For more detailed information on managing and revoking authentication keys, please refer to the ",(0,s.jsx)(n.a,{href:"./token-managers/managing-tokens#revoking-tokens",children:"Managing tokens"})," section."]})]}),"\n",(0,s.jsx)(n.h4,{id:"sign-out-current-device",children:"Sign out current device"}),"\n",(0,s.jsx)(n.p,{children:"To sign the user out from the current device:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"await client.auth.signOutDevice();\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Returns ",(0,s.jsx)(n.code,{children:"true"})," if the sign-out is successful, or ",(0,s.jsx)(n.code,{children:"false"})," if it fails. Either way, the sign-out will be performed on the application and update the authentication state."]}),"\n",(0,s.jsx)(n.h4,{id:"sign-out-all-devices",children:"Sign out all devices"}),"\n",(0,s.jsx)(n.p,{children:"To sign the user out across all devices:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"await client.auth.signOutAllDevices();\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Returns ",(0,s.jsx)(n.code,{children:"true"})," if the user is successfully signed out from all devices, or ",(0,s.jsx)(n.code,{children:"false"})," if it fails. Also proceed with the sign-out on the application regardless of the result of the operation on the server."]})]})}function l(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},28453(e,n,t){t.d(n,{R:()=>a,x:()=>r});var i=t(96540);const s={},o=i.createContext(s);function a(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);