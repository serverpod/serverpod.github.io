"use strict";(self.webpackChunkserverpod_docs=self.webpackChunkserverpod_docs||[]).push([[55367],{12542:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"concepts/backward-compatibility","title":"Backward compatibility","description":"As your app evolves, features will be added or changed. However, your users may still use older versions of the app as not everyone will update to the latest version and automatic updates through the app stores take time. Therefore it may be essential to make updates to your server compatible with older app versions.","source":"@site/versioned_docs/version-2.8.0/06-concepts/17-backward-compatibility.md","sourceDirName":"06-concepts","slug":"/concepts/backward-compatibility","permalink":"/2.8.0/concepts/backward-compatibility","draft":false,"unlisted":false,"editUrl":"https://github.com/serverpod/serverpod_docs/tree/main/versioned_docs/version-2.8.0/06-concepts/17-backward-compatibility.md","tags":[],"version":"2.8.0","sidebarPosition":17,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Server events","permalink":"/2.8.0/concepts/server-events"},"next":{"title":"Web server","permalink":"/2.8.0/concepts/webserver"}}');var i=t(74848),a=t(28453);const s={},r="Backward compatibility",d={},l=[{value:"Managing breaking changes with endpoint inheritance",id:"managing-breaking-changes-with-endpoint-inheritance",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"backward-compatibility",children:"Backward compatibility"})}),"\n",(0,i.jsx)(n.p,{children:"As your app evolves, features will be added or changed. However, your users may still use older versions of the app as not everyone will update to the latest version and automatic updates through the app stores take time. Therefore it may be essential to make updates to your server compatible with older app versions."}),"\n",(0,i.jsx)(n.p,{children:"Following a simple set of rules, your server will stay compatible with older app versions:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Avoid changing parameter names in endpoint methods."})," In the REST API Serverpod generates, the parameters are passed by name. This means that changing the parameter names of the endpoint methods will break backward compatibility."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Do not delete endpoint methods or change their signature."})," Instead, add new methods if you must pass another set of parameters. Technically, you can add new named parameters if they are not required, but creating a new method may still feel cleaner."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Avoid changing or removing fields and types in the serialized classes."})," However, you are free to add new fields as long as they are nullable."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"managing-breaking-changes-with-endpoint-inheritance",children:"Managing breaking changes with endpoint inheritance"}),"\n",(0,i.jsxs)(n.p,{children:["An ",(0,i.jsx)(n.a,{href:"/concepts/working-with-endpoints",children:"endpoint sub-class"})," can be useful when you have to make a breaking change to an entire endpoint but need to keep supporting existing clients. Doing so allows you to share most of its implementation with the old endpoint."]}),"\n",(0,i.jsx)(n.p,{children:'Imagine you had a "team" management endpoint where before a user could join if they had an e-mail address ending in the expected domain, but now it should be opened up for anyone to join if they can provide an "invite code". Additionally, the return type (serialized classes) should be updated across the entire endpoint, which would not be allowed on the existing one.'}),"\n",(0,i.jsx)(n.p,{children:"Transitioning from the current to the new endpoint structure might look like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"@Deprecated('Use TeamV2Endpoint instead')\nclass TeamEndpoint extends Endpoint {\n  Future<TeamInfo> join(Session session) async {\n    // \u2026\n  }\n  \n  // many more methods, like `leave`, etc.\n}\n\nclass TeamV2Endpoint extends TeamEndpoint {\n  @override\n  @doNotGenerate\n  Future<TeamInfo> join(Session session) async {\n    throw UnimplementedError();\n  }\n\n  Future<NewTeamInfo> joinWithCode(Session session, String invitationCode) async {\n    // \u2026\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In the above example, we created a new ",(0,i.jsx)(n.code,{children:"TeamV2"})," endpoint, which hides the ",(0,i.jsx)(n.code,{children:"join"})," method and instead exposes a ",(0,i.jsx)(n.code,{children:"joinWithCode"})," method with the added parameter and the new return type. Additionally all the other inherited (and untouched) methods from the parent class are exposed."]}),"\n",(0,i.jsxs)(n.p,{children:["While we may have liked to re-use the ",(0,i.jsx)(n.code,{children:"join"})," method name, Dart inheritance rules do not allow doing so. Otherwise, we would have to write the endpoint from scratch, meaning without inheritance, and re-implement all methods we would like to keep."]}),"\n",(0,i.jsxs)(n.p,{children:["In your client, you could then move all usages from ",(0,i.jsx)(n.code,{children:"client.team"})," to ",(0,i.jsx)(n.code,{children:"client.teamV2"})," and eventually (after all clients have upgraded) remove the old endpoint on the server. That means either marking the old endpoint with ",(0,i.jsx)(n.code,{children:"@doNotGenerate"})," on the class or deleting it and moving the re-used method implementations you want to keep to the new V2 endpoint class."]}),"\n",(0,i.jsx)(n.p,{children:"An alternative pattern to consider would be to move all the business logic for an endpoint into a helper class and then call into that from the endpoint. In case you want to create a V2 version later, you might be able to reuse most of the underlying business logic through that helper class, and don't have to subclass the old endpoint. This has the added benefit of the endpoint class clearly listing all exposed methods, and you don't have to wonder what you inherit from the base class."}),"\n",(0,i.jsx)(n.p,{children:"Either approach has pros and cons, and it depends on the concrete circumstances to pick the most useful one. Both give you all the tools you need to extend and update your API while gracefully moving clients along and giving them time to update."})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>r});var o=t(96540);const i={},a=o.createContext(i);function s(e){const n=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),o.createElement(a.Provider,{value:n},e.children)}}}]);